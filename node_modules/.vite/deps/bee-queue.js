import {
  require_fs,
  require_path,
  require_util
} from "./chunk-MBOSZ5XW.js";
import {
  __commonJS
} from "./chunk-5WWUZCGV.js";

// browser-external:net
var require_net = __commonJS({
  "browser-external:net"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "net" has been externalized for browser compatibility. Cannot access "net.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:tls
var require_tls = __commonJS({
  "browser-external:tls"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "tls" has been externalized for browser compatibility. Cannot access "tls.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/redis/lib/utils.js
var require_utils = __commonJS({
  "node_modules/redis/lib/utils.js"(exports, module) {
    "use strict";
    function replyToObject(reply) {
      if (reply.length === 0 || !(reply instanceof Array)) {
        return null;
      }
      var obj = {};
      for (var i = 0; i < reply.length; i += 2) {
        obj[reply[i].toString("binary")] = reply[i + 1];
      }
      return obj;
    }
    function replyToStrings(reply) {
      if (reply instanceof Buffer) {
        return reply.toString();
      }
      if (reply instanceof Array) {
        var res = new Array(reply.length);
        for (var i = 0; i < reply.length; i++) {
          res[i] = replyToStrings(reply[i]);
        }
        return res;
      }
      return reply;
    }
    function print(err, reply) {
      if (err) {
        console.log(err.toString());
      } else {
        console.log("Reply: " + reply);
      }
    }
    var camelCase;
    function clone(obj) {
      var copy;
      if (Array.isArray(obj)) {
        copy = new Array(obj.length);
        for (var i = 0; i < obj.length; i++) {
          copy[i] = clone(obj[i]);
        }
        return copy;
      }
      if (Object.prototype.toString.call(obj) === "[object Object]") {
        copy = {};
        var elems = Object.keys(obj);
        var elem;
        while (elem = elems.pop()) {
          if (elem === "tls") {
            copy[elem] = obj[elem];
            continue;
          }
          var snake_case = elem.replace(/[A-Z][^A-Z]/g, "_$&").toLowerCase();
          if (snake_case !== elem.toLowerCase()) {
            camelCase = true;
          }
          copy[snake_case] = clone(obj[elem]);
        }
        return copy;
      }
      return obj;
    }
    function convenienceClone(obj) {
      camelCase = false;
      obj = clone(obj) || {};
      if (camelCase) {
        obj.camel_case = true;
      }
      return obj;
    }
    function callbackOrEmit(self, callback, err, res) {
      if (callback) {
        callback(err, res);
      } else if (err) {
        self.emit("error", err);
      }
    }
    function replyInOrder(self, callback, err, res, queue) {
      var command_obj;
      if (queue) {
        command_obj = queue.peekBack();
      } else {
        command_obj = self.offline_queue.peekBack() || self.command_queue.peekBack();
      }
      if (!command_obj) {
        process.nextTick(function() {
          callbackOrEmit(self, callback, err, res);
        });
      } else {
        var tmp = command_obj.callback;
        command_obj.callback = tmp ? function(e, r) {
          tmp(e, r);
          callbackOrEmit(self, callback, err, res);
        } : function(e, r) {
          if (e) {
            self.emit("error", e);
          }
          callbackOrEmit(self, callback, err, res);
        };
      }
    }
    module.exports = {
      reply_to_strings: replyToStrings,
      reply_to_object: replyToObject,
      print,
      err_code: /^([A-Z]+)\s+(.+)$/,
      monitor_regex: /^[0-9]{10,11}\.[0-9]+ \[[0-9]+ .+\].*"$/,
      clone: convenienceClone,
      callback_or_emit: callbackOrEmit,
      reply_in_order: replyInOrder
    };
  }
});

// node_modules/redis/lib/command.js
var require_command = __commonJS({
  "node_modules/redis/lib/command.js"(exports, module) {
    "use strict";
    var betterStackTraces = /development/i.test("development") || /\bredis\b/i.test(process.env.NODE_DEBUG);
    function Command(command, args, callback, call_on_write) {
      this.command = command;
      this.args = args;
      this.buffer_args = false;
      this.callback = callback;
      this.call_on_write = call_on_write;
      if (betterStackTraces) {
        this.error = new Error();
      }
    }
    module.exports = Command;
  }
});

// node_modules/denque/index.js
var require_denque = __commonJS({
  "node_modules/denque/index.js"(exports, module) {
    "use strict";
    function Denque(array, options) {
      var options = options || {};
      this._head = 0;
      this._tail = 0;
      this._capacity = options.capacity;
      this._capacityMask = 3;
      this._list = new Array(4);
      if (Array.isArray(array)) {
        this._fromArray(array);
      }
    }
    Denque.prototype.peekAt = function peekAt(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i >= len || i < -len)
        return void 0;
      if (i < 0)
        i += len;
      i = this._head + i & this._capacityMask;
      return this._list[i];
    };
    Denque.prototype.get = function get(i) {
      return this.peekAt(i);
    };
    Denque.prototype.peek = function peek() {
      if (this._head === this._tail)
        return void 0;
      return this._list[this._head];
    };
    Denque.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque.prototype, "length", {
      get: function length() {
        return this.size();
      }
    });
    Denque.prototype.size = function size() {
      if (this._head === this._tail)
        return 0;
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.unshift = function unshift(item) {
      if (item === void 0)
        return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head)
        this._growArray();
      if (this._capacity && this.size() > this._capacity)
        this.pop();
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.shift = function shift() {
      var head = this._head;
      if (head === this._tail)
        return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.push = function push(item) {
      if (item === void 0)
        return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head)
        return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.removeOne = function removeOne(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size)
        return void 0;
      if (i < 0)
        i += size;
      i = this._head + i & this._capacityMask;
      var item = this._list[i];
      var k;
      if (index < size / 2) {
        for (k = index; k > 0; k--) {
          this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index; k > 0; k--) {
          this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque.prototype.remove = function remove(index, count) {
      var i = index;
      var removed;
      var del_count = count;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size || count < 1)
        return void 0;
      if (i < 0)
        i += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i);
        return removed;
      }
      if (i === 0 && i + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i + count > size)
        count = size - i;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i + k & this._capacityMask];
      }
      i = this._head + i & this._capacityMask;
      if (index + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i < size / 2) {
        this._head = this._head + index + count + len & this._capacityMask;
        for (k = index; k > 0; k--) {
          this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
        }
        i = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i = i - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index < 0)
          this._tail = i;
      } else {
        this._tail = i;
        i = i + count + len & this._capacityMask;
        for (k = size - (count + index); k > 0; k--) {
          this.push(this._list[i++]);
        }
        i = this._tail;
        while (del_count > 0) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
        this._shrinkArray();
      return removed;
    };
    Denque.prototype.splice = function splice(index, count) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i < 0)
        i += size;
      if (i > size)
        return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i < size / 2) {
          temp = new Array(i);
          for (k = 0; k < i; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i > 0) {
              this._head = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._head = this._head + i + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i != size) {
              this._tail = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i, count);
      }
    };
    Denque.prototype.clear = function clear() {
      this._head = 0;
      this._tail = 0;
    };
    Denque.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque.prototype.toArray = function toArray() {
      return this._copyArray(false);
    };
    Denque.prototype._fromArray = function _fromArray(array) {
      for (var i = 0; i < array.length; i++)
        this.push(array[i]);
    };
    Denque.prototype._copyArray = function _copyArray(fullCopy) {
      var newArray = [];
      var list = this._list;
      var len = list.length;
      var i;
      if (fullCopy || this._head > this._tail) {
        for (i = this._head; i < len; i++)
          newArray.push(list[i]);
        for (i = 0; i < this._tail; i++)
          newArray.push(list[i]);
      } else {
        for (i = this._head; i < this._tail; i++)
          newArray.push(list[i]);
      }
      return newArray;
    };
    Denque.prototype._growArray = function _growArray() {
      if (this._head) {
        this._list = this._copyArray(true);
        this._head = 0;
      }
      this._tail = this._list.length;
      this._list.length <<= 1;
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    module.exports = Denque;
  }
});

// browser-external:assert
var require_assert = __commonJS({
  "browser-external:assert"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "assert" has been externalized for browser compatibility. Cannot access "assert.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/redis-errors/lib/old.js
var require_old = __commonJS({
  "node_modules/redis-errors/lib/old.js"(exports, module) {
    "use strict";
    var assert = require_assert();
    var util = require_util();
    function RedisError(message) {
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      Error.captureStackTrace(this, this.constructor);
    }
    util.inherits(RedisError, Error);
    Object.defineProperty(RedisError.prototype, "name", {
      value: "RedisError",
      configurable: true,
      writable: true
    });
    function ParserError(message, buffer, offset) {
      assert(buffer);
      assert.strictEqual(typeof offset, "number");
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      const tmp = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      Error.captureStackTrace(this, this.constructor);
      Error.stackTraceLimit = tmp;
      this.offset = offset;
      this.buffer = buffer;
    }
    util.inherits(ParserError, RedisError);
    Object.defineProperty(ParserError.prototype, "name", {
      value: "ParserError",
      configurable: true,
      writable: true
    });
    function ReplyError(message) {
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      const tmp = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      Error.captureStackTrace(this, this.constructor);
      Error.stackTraceLimit = tmp;
    }
    util.inherits(ReplyError, RedisError);
    Object.defineProperty(ReplyError.prototype, "name", {
      value: "ReplyError",
      configurable: true,
      writable: true
    });
    function AbortError(message) {
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      Error.captureStackTrace(this, this.constructor);
    }
    util.inherits(AbortError, RedisError);
    Object.defineProperty(AbortError.prototype, "name", {
      value: "AbortError",
      configurable: true,
      writable: true
    });
    function InterruptError(message) {
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      Error.captureStackTrace(this, this.constructor);
    }
    util.inherits(InterruptError, AbortError);
    Object.defineProperty(InterruptError.prototype, "name", {
      value: "InterruptError",
      configurable: true,
      writable: true
    });
    module.exports = {
      RedisError,
      ParserError,
      ReplyError,
      AbortError,
      InterruptError
    };
  }
});

// node_modules/redis-errors/lib/modern.js
var require_modern = __commonJS({
  "node_modules/redis-errors/lib/modern.js"(exports, module) {
    "use strict";
    var assert = require_assert();
    var RedisError = class extends Error {
      get name() {
        return this.constructor.name;
      }
    };
    var ParserError = class extends RedisError {
      constructor(message, buffer, offset) {
        assert(buffer);
        assert.strictEqual(typeof offset, "number");
        const tmp = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        super(message);
        Error.stackTraceLimit = tmp;
        this.offset = offset;
        this.buffer = buffer;
      }
      get name() {
        return this.constructor.name;
      }
    };
    var ReplyError = class extends RedisError {
      constructor(message) {
        const tmp = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        super(message);
        Error.stackTraceLimit = tmp;
      }
      get name() {
        return this.constructor.name;
      }
    };
    var AbortError = class extends RedisError {
      get name() {
        return this.constructor.name;
      }
    };
    var InterruptError = class extends AbortError {
      get name() {
        return this.constructor.name;
      }
    };
    module.exports = {
      RedisError,
      ParserError,
      ReplyError,
      AbortError,
      InterruptError
    };
  }
});

// node_modules/redis-errors/index.js
var require_redis_errors = __commonJS({
  "node_modules/redis-errors/index.js"(exports, module) {
    "use strict";
    var Errors = process.version.charCodeAt(1) < 55 && process.version.charCodeAt(2) === 46 ? require_old() : require_modern();
    module.exports = Errors;
  }
});

// node_modules/redis/lib/customErrors.js
var require_customErrors = __commonJS({
  "node_modules/redis/lib/customErrors.js"(exports, module) {
    "use strict";
    var util = require_util();
    var assert = require_assert();
    var RedisError = require_redis_errors().RedisError;
    var ADD_STACKTRACE = false;
    function AbortError(obj, stack) {
      assert(obj, "The options argument is required");
      assert.strictEqual(typeof obj, "object", "The options argument has to be of type object");
      Object.defineProperty(this, "message", {
        value: obj.message || "",
        configurable: true,
        writable: true
      });
      if (stack || stack === void 0) {
        Error.captureStackTrace(this, AbortError);
      }
      for (var keys = Object.keys(obj), key = keys.pop(); key; key = keys.pop()) {
        this[key] = obj[key];
      }
    }
    function AggregateError2(obj) {
      assert(obj, "The options argument is required");
      assert.strictEqual(typeof obj, "object", "The options argument has to be of type object");
      AbortError.call(this, obj, ADD_STACKTRACE);
      Object.defineProperty(this, "message", {
        value: obj.message || "",
        configurable: true,
        writable: true
      });
      Error.captureStackTrace(this, AggregateError2);
      for (var keys = Object.keys(obj), key = keys.pop(); key; key = keys.pop()) {
        this[key] = obj[key];
      }
    }
    util.inherits(AbortError, RedisError);
    util.inherits(AggregateError2, AbortError);
    Object.defineProperty(AbortError.prototype, "name", {
      value: "AbortError",
      configurable: true,
      writable: true
    });
    Object.defineProperty(AggregateError2.prototype, "name", {
      value: "AggregateError",
      configurable: true,
      writable: true
    });
    module.exports = {
      AbortError,
      AggregateError: AggregateError2
    };
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer2.isBuffer(buf))
              buf = Buffer2.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self.lastNeed = 0;
        return "";
      }
      if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self.lastNeed = 1;
          return "";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self.lastNeed = 2;
            return "";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/redis-parser/lib/parser.js
var require_parser = __commonJS({
  "node_modules/redis-parser/lib/parser.js"(exports, module) {
    "use strict";
    var Buffer2 = require_buffer().Buffer;
    var StringDecoder = require_string_decoder().StringDecoder;
    var decoder = new StringDecoder();
    var errors = require_redis_errors();
    var ReplyError = errors.ReplyError;
    var ParserError = errors.ParserError;
    var bufferPool = Buffer2.allocUnsafe(32 * 1024);
    var bufferOffset = 0;
    var interval = null;
    var counter = 0;
    var notDecreased = 0;
    function parseSimpleNumbers(parser) {
      const length = parser.buffer.length - 1;
      var offset = parser.offset;
      var number = 0;
      var sign = 1;
      if (parser.buffer[offset] === 45) {
        sign = -1;
        offset++;
      }
      while (offset < length) {
        const c1 = parser.buffer[offset++];
        if (c1 === 13) {
          parser.offset = offset + 1;
          return sign * number;
        }
        number = number * 10 + (c1 - 48);
      }
    }
    function parseStringNumbers(parser) {
      const length = parser.buffer.length - 1;
      var offset = parser.offset;
      var number = 0;
      var res = "";
      if (parser.buffer[offset] === 45) {
        res += "-";
        offset++;
      }
      while (offset < length) {
        var c1 = parser.buffer[offset++];
        if (c1 === 13) {
          parser.offset = offset + 1;
          if (number !== 0) {
            res += number;
          }
          return res;
        } else if (number > 429496728) {
          res += number * 10 + (c1 - 48);
          number = 0;
        } else if (c1 === 48 && number === 0) {
          res += 0;
        } else {
          number = number * 10 + (c1 - 48);
        }
      }
    }
    function parseSimpleString(parser) {
      const start = parser.offset;
      const buffer = parser.buffer;
      const length = buffer.length - 1;
      var offset = start;
      while (offset < length) {
        if (buffer[offset++] === 13) {
          parser.offset = offset + 1;
          if (parser.optionReturnBuffers === true) {
            return parser.buffer.slice(start, offset - 1);
          }
          return parser.buffer.toString("utf8", start, offset - 1);
        }
      }
    }
    function parseLength(parser) {
      const length = parser.buffer.length - 1;
      var offset = parser.offset;
      var number = 0;
      while (offset < length) {
        const c1 = parser.buffer[offset++];
        if (c1 === 13) {
          parser.offset = offset + 1;
          return number;
        }
        number = number * 10 + (c1 - 48);
      }
    }
    function parseInteger(parser) {
      if (parser.optionStringNumbers === true) {
        return parseStringNumbers(parser);
      }
      return parseSimpleNumbers(parser);
    }
    function parseBulkString(parser) {
      const length = parseLength(parser);
      if (length === void 0) {
        return;
      }
      if (length < 0) {
        return null;
      }
      const offset = parser.offset + length;
      if (offset + 2 > parser.buffer.length) {
        parser.bigStrSize = offset + 2;
        parser.totalChunkSize = parser.buffer.length;
        parser.bufferCache.push(parser.buffer);
        return;
      }
      const start = parser.offset;
      parser.offset = offset + 2;
      if (parser.optionReturnBuffers === true) {
        return parser.buffer.slice(start, offset);
      }
      return parser.buffer.toString("utf8", start, offset);
    }
    function parseError(parser) {
      var string = parseSimpleString(parser);
      if (string !== void 0) {
        if (parser.optionReturnBuffers === true) {
          string = string.toString();
        }
        return new ReplyError(string);
      }
    }
    function handleError(parser, type) {
      const err = new ParserError(
        "Protocol error, got " + JSON.stringify(String.fromCharCode(type)) + " as reply type byte",
        JSON.stringify(parser.buffer),
        parser.offset
      );
      parser.buffer = null;
      parser.returnFatalError(err);
    }
    function parseArray(parser) {
      const length = parseLength(parser);
      if (length === void 0) {
        return;
      }
      if (length < 0) {
        return null;
      }
      const responses = new Array(length);
      return parseArrayElements(parser, responses, 0);
    }
    function pushArrayCache(parser, array, pos) {
      parser.arrayCache.push(array);
      parser.arrayPos.push(pos);
    }
    function parseArrayChunks(parser) {
      const tmp = parser.arrayCache.pop();
      var pos = parser.arrayPos.pop();
      if (parser.arrayCache.length) {
        const res = parseArrayChunks(parser);
        if (res === void 0) {
          pushArrayCache(parser, tmp, pos);
          return;
        }
        tmp[pos++] = res;
      }
      return parseArrayElements(parser, tmp, pos);
    }
    function parseArrayElements(parser, responses, i) {
      const bufferLength = parser.buffer.length;
      while (i < responses.length) {
        const offset = parser.offset;
        if (parser.offset >= bufferLength) {
          pushArrayCache(parser, responses, i);
          return;
        }
        const response = parseType(parser, parser.buffer[parser.offset++]);
        if (response === void 0) {
          if (!(parser.arrayCache.length || parser.bufferCache.length)) {
            parser.offset = offset;
          }
          pushArrayCache(parser, responses, i);
          return;
        }
        responses[i] = response;
        i++;
      }
      return responses;
    }
    function parseType(parser, type) {
      switch (type) {
        case 36:
          return parseBulkString(parser);
        case 43:
          return parseSimpleString(parser);
        case 42:
          return parseArray(parser);
        case 58:
          return parseInteger(parser);
        case 45:
          return parseError(parser);
        default:
          return handleError(parser, type);
      }
    }
    function decreaseBufferPool() {
      if (bufferPool.length > 50 * 1024) {
        if (counter === 1 || notDecreased > counter * 2) {
          const minSliceLen = Math.floor(bufferPool.length / 10);
          const sliceLength = minSliceLen < bufferOffset ? bufferOffset : minSliceLen;
          bufferOffset = 0;
          bufferPool = bufferPool.slice(sliceLength, bufferPool.length);
        } else {
          notDecreased++;
          counter--;
        }
      } else {
        clearInterval(interval);
        counter = 0;
        notDecreased = 0;
        interval = null;
      }
    }
    function resizeBuffer(length) {
      if (bufferPool.length < length + bufferOffset) {
        const multiplier = length > 1024 * 1024 * 75 ? 2 : 3;
        if (bufferOffset > 1024 * 1024 * 111) {
          bufferOffset = 1024 * 1024 * 50;
        }
        bufferPool = Buffer2.allocUnsafe(length * multiplier + bufferOffset);
        bufferOffset = 0;
        counter++;
        if (interval === null) {
          interval = setInterval(decreaseBufferPool, 50);
        }
      }
    }
    function concatBulkString(parser) {
      const list = parser.bufferCache;
      const oldOffset = parser.offset;
      var chunks = list.length;
      var offset = parser.bigStrSize - parser.totalChunkSize;
      parser.offset = offset;
      if (offset <= 2) {
        if (chunks === 2) {
          return list[0].toString("utf8", oldOffset, list[0].length + offset - 2);
        }
        chunks--;
        offset = list[list.length - 2].length + offset;
      }
      var res = decoder.write(list[0].slice(oldOffset));
      for (var i = 1; i < chunks - 1; i++) {
        res += decoder.write(list[i]);
      }
      res += decoder.end(list[i].slice(0, offset - 2));
      return res;
    }
    function concatBulkBuffer(parser) {
      const list = parser.bufferCache;
      const oldOffset = parser.offset;
      const length = parser.bigStrSize - oldOffset - 2;
      var chunks = list.length;
      var offset = parser.bigStrSize - parser.totalChunkSize;
      parser.offset = offset;
      if (offset <= 2) {
        if (chunks === 2) {
          return list[0].slice(oldOffset, list[0].length + offset - 2);
        }
        chunks--;
        offset = list[list.length - 2].length + offset;
      }
      resizeBuffer(length);
      const start = bufferOffset;
      list[0].copy(bufferPool, start, oldOffset, list[0].length);
      bufferOffset += list[0].length - oldOffset;
      for (var i = 1; i < chunks - 1; i++) {
        list[i].copy(bufferPool, bufferOffset);
        bufferOffset += list[i].length;
      }
      list[i].copy(bufferPool, bufferOffset, 0, offset - 2);
      bufferOffset += offset - 2;
      return bufferPool.slice(start, bufferOffset);
    }
    var JavascriptRedisParser = class {
      /**
       * Javascript Redis Parser constructor
       * @param {{returnError: Function, returnReply: Function, returnFatalError?: Function, returnBuffers: boolean, stringNumbers: boolean }} options
       * @constructor
       */
      constructor(options) {
        if (!options) {
          throw new TypeError("Options are mandatory.");
        }
        if (typeof options.returnError !== "function" || typeof options.returnReply !== "function") {
          throw new TypeError("The returnReply and returnError options have to be functions.");
        }
        this.setReturnBuffers(!!options.returnBuffers);
        this.setStringNumbers(!!options.stringNumbers);
        this.returnError = options.returnError;
        this.returnFatalError = options.returnFatalError || options.returnError;
        this.returnReply = options.returnReply;
        this.reset();
      }
      /**
       * Reset the parser values to the initial state
       *
       * @returns {undefined}
       */
      reset() {
        this.offset = 0;
        this.buffer = null;
        this.bigStrSize = 0;
        this.totalChunkSize = 0;
        this.bufferCache = [];
        this.arrayCache = [];
        this.arrayPos = [];
      }
      /**
       * Set the returnBuffers option
       *
       * @param {boolean} returnBuffers
       * @returns {undefined}
       */
      setReturnBuffers(returnBuffers) {
        if (typeof returnBuffers !== "boolean") {
          throw new TypeError("The returnBuffers argument has to be a boolean");
        }
        this.optionReturnBuffers = returnBuffers;
      }
      /**
       * Set the stringNumbers option
       *
       * @param {boolean} stringNumbers
       * @returns {undefined}
       */
      setStringNumbers(stringNumbers) {
        if (typeof stringNumbers !== "boolean") {
          throw new TypeError("The stringNumbers argument has to be a boolean");
        }
        this.optionStringNumbers = stringNumbers;
      }
      /**
       * Parse the redis buffer
       * @param {Buffer} buffer
       * @returns {undefined}
       */
      execute(buffer) {
        if (this.buffer === null) {
          this.buffer = buffer;
          this.offset = 0;
        } else if (this.bigStrSize === 0) {
          const oldLength = this.buffer.length;
          const remainingLength = oldLength - this.offset;
          const newBuffer = Buffer2.allocUnsafe(remainingLength + buffer.length);
          this.buffer.copy(newBuffer, 0, this.offset, oldLength);
          buffer.copy(newBuffer, remainingLength, 0, buffer.length);
          this.buffer = newBuffer;
          this.offset = 0;
          if (this.arrayCache.length) {
            const arr = parseArrayChunks(this);
            if (arr === void 0) {
              return;
            }
            this.returnReply(arr);
          }
        } else if (this.totalChunkSize + buffer.length >= this.bigStrSize) {
          this.bufferCache.push(buffer);
          var tmp = this.optionReturnBuffers ? concatBulkBuffer(this) : concatBulkString(this);
          this.bigStrSize = 0;
          this.bufferCache = [];
          this.buffer = buffer;
          if (this.arrayCache.length) {
            this.arrayCache[0][this.arrayPos[0]++] = tmp;
            tmp = parseArrayChunks(this);
            if (tmp === void 0) {
              return;
            }
          }
          this.returnReply(tmp);
        } else {
          this.bufferCache.push(buffer);
          this.totalChunkSize += buffer.length;
          return;
        }
        while (this.offset < this.buffer.length) {
          const offset = this.offset;
          const type = this.buffer[this.offset++];
          const response = parseType(this, type);
          if (response === void 0) {
            if (!(this.arrayCache.length || this.bufferCache.length)) {
              this.offset = offset;
            }
            return;
          }
          if (type === 45) {
            this.returnError(response);
          } else {
            this.returnReply(response);
          }
        }
        this.buffer = null;
      }
    };
    module.exports = JavascriptRedisParser;
  }
});

// node_modules/redis-parser/index.js
var require_redis_parser = __commonJS({
  "node_modules/redis-parser/index.js"(exports, module) {
    "use strict";
    module.exports = require_parser();
  }
});

// node_modules/redis-commands/commands.json
var require_commands = __commonJS({
  "node_modules/redis-commands/commands.json"(exports, module) {
    module.exports = {
      acl: {
        arity: -2,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale",
          "skip_slowlog"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      append: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      asking: {
        arity: 1,
        flags: [
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      auth: {
        arity: -2,
        flags: [
          "noscript",
          "loading",
          "stale",
          "skip_monitor",
          "skip_slowlog",
          "fast",
          "no_auth"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      bgrewriteaof: {
        arity: 1,
        flags: [
          "admin",
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      bgsave: {
        arity: -1,
        flags: [
          "admin",
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      bitcount: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      bitfield: {
        arity: -2,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      bitfield_ro: {
        arity: -2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      bitop: {
        arity: -4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 2,
        keyStop: -1,
        step: 1
      },
      bitpos: {
        arity: -3,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      blmove: {
        arity: 6,
        flags: [
          "write",
          "denyoom",
          "noscript"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      blpop: {
        arity: -3,
        flags: [
          "write",
          "noscript"
        ],
        keyStart: 1,
        keyStop: -2,
        step: 1
      },
      brpop: {
        arity: -3,
        flags: [
          "write",
          "noscript"
        ],
        keyStart: 1,
        keyStop: -2,
        step: 1
      },
      brpoplpush: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "noscript"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      bzpopmax: {
        arity: -3,
        flags: [
          "write",
          "noscript",
          "fast"
        ],
        keyStart: 1,
        keyStop: -2,
        step: 1
      },
      bzpopmin: {
        arity: -3,
        flags: [
          "write",
          "noscript",
          "fast"
        ],
        keyStart: 1,
        keyStop: -2,
        step: 1
      },
      client: {
        arity: -2,
        flags: [
          "admin",
          "noscript",
          "random",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      cluster: {
        arity: -2,
        flags: [
          "admin",
          "random",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      command: {
        arity: -1,
        flags: [
          "random",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      config: {
        arity: -2,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      copy: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      dbsize: {
        arity: 1,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      debug: {
        arity: -2,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      decr: {
        arity: 2,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      decrby: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      del: {
        arity: -2,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      discard: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      dump: {
        arity: 2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      echo: {
        arity: 2,
        flags: [
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      eval: {
        arity: -3,
        flags: [
          "noscript",
          "may_replicate",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      evalsha: {
        arity: -3,
        flags: [
          "noscript",
          "may_replicate",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      exec: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "skip_monitor",
          "skip_slowlog"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      exists: {
        arity: -2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      expire: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      expireat: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      failover: {
        arity: -1,
        flags: [
          "admin",
          "noscript",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      flushall: {
        arity: -1,
        flags: [
          "write"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      flushdb: {
        arity: -1,
        flags: [
          "write"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      geoadd: {
        arity: -5,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geodist: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geohash: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geopos: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      georadius: {
        arity: -6,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      georadius_ro: {
        arity: -6,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      georadiusbymember: {
        arity: -5,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      georadiusbymember_ro: {
        arity: -5,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geosearch: {
        arity: -7,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geosearchstore: {
        arity: -8,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      get: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getbit: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getdel: {
        arity: 2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getex: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getrange: {
        arity: 4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getset: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hdel: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hello: {
        arity: -1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "skip_monitor",
          "skip_slowlog",
          "fast",
          "no_auth"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      hexists: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hget: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hgetall: {
        arity: 2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hincrby: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hincrbyfloat: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hkeys: {
        arity: 2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hlen: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hmget: {
        arity: -3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hmset: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      "host:": {
        arity: -1,
        flags: [
          "readonly",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      hrandfield: {
        arity: -2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hscan: {
        arity: -3,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hset: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hsetnx: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hstrlen: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hvals: {
        arity: 2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      incr: {
        arity: 2,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      incrby: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      incrbyfloat: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      info: {
        arity: -1,
        flags: [
          "random",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      keys: {
        arity: 2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      lastsave: {
        arity: 1,
        flags: [
          "random",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      latency: {
        arity: -2,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      lindex: {
        arity: 3,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      linsert: {
        arity: 5,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      llen: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lmove: {
        arity: 5,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      lolwut: {
        arity: -1,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      lpop: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lpos: {
        arity: -3,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lpush: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lpushx: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lrange: {
        arity: 4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lrem: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lset: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      ltrim: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      memory: {
        arity: -2,
        flags: [
          "readonly",
          "random",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      mget: {
        arity: -2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      migrate: {
        arity: -6,
        flags: [
          "write",
          "random",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      module: {
        arity: -2,
        flags: [
          "admin",
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      monitor: {
        arity: 1,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      move: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      mset: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 2
      },
      msetnx: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 2
      },
      multi: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      object: {
        arity: -2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 2,
        keyStop: 2,
        step: 1
      },
      persist: {
        arity: 2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      pexpire: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      pexpireat: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      pfadd: {
        arity: -2,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      pfcount: {
        arity: -2,
        flags: [
          "readonly",
          "may_replicate"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      pfdebug: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "admin"
        ],
        keyStart: 2,
        keyStop: 2,
        step: 1
      },
      pfmerge: {
        arity: -2,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      pfselftest: {
        arity: 1,
        flags: [
          "admin"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      ping: {
        arity: -1,
        flags: [
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      post: {
        arity: -1,
        flags: [
          "readonly",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      psetex: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      psubscribe: {
        arity: -2,
        flags: [
          "pubsub",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      psync: {
        arity: -3,
        flags: [
          "admin",
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      pttl: {
        arity: 2,
        flags: [
          "readonly",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      publish: {
        arity: 3,
        flags: [
          "pubsub",
          "loading",
          "stale",
          "fast",
          "may_replicate"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      pubsub: {
        arity: -2,
        flags: [
          "pubsub",
          "random",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      punsubscribe: {
        arity: -1,
        flags: [
          "pubsub",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      quit: {
        arity: 1,
        flags: [
          "loading",
          "stale",
          "readonly"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      randomkey: {
        arity: 1,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      readonly: {
        arity: 1,
        flags: [
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      readwrite: {
        arity: 1,
        flags: [
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      rename: {
        arity: 3,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      renamenx: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      replconf: {
        arity: -1,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      replicaof: {
        arity: 3,
        flags: [
          "admin",
          "noscript",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      reset: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      restore: {
        arity: -4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      "restore-asking": {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "asking"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      role: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      rpop: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      rpoplpush: {
        arity: 3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      rpush: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      rpushx: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      sadd: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      save: {
        arity: 1,
        flags: [
          "admin",
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      scan: {
        arity: -2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      scard: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      script: {
        arity: -2,
        flags: [
          "noscript",
          "may_replicate"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      sdiff: {
        arity: -2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      sdiffstore: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      select: {
        arity: 2,
        flags: [
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      set: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      setbit: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      setex: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      setnx: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      setrange: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      shutdown: {
        arity: -1,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      sinter: {
        arity: -2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      sinterstore: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      sismember: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      slaveof: {
        arity: 3,
        flags: [
          "admin",
          "noscript",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      slowlog: {
        arity: -2,
        flags: [
          "admin",
          "random",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      smembers: {
        arity: 2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      smismember: {
        arity: -3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      smove: {
        arity: 4,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      sort: {
        arity: -2,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      spop: {
        arity: -2,
        flags: [
          "write",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      srandmember: {
        arity: -2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      srem: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      sscan: {
        arity: -3,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      stralgo: {
        arity: -2,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      strlen: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      subscribe: {
        arity: -2,
        flags: [
          "pubsub",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      substr: {
        arity: 4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      sunion: {
        arity: -2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      sunionstore: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      swapdb: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      sync: {
        arity: 1,
        flags: [
          "admin",
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      time: {
        arity: 1,
        flags: [
          "random",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      touch: {
        arity: -2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      ttl: {
        arity: 2,
        flags: [
          "readonly",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      type: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      unlink: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      unsubscribe: {
        arity: -1,
        flags: [
          "pubsub",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      unwatch: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      wait: {
        arity: 3,
        flags: [
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      watch: {
        arity: -2,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      xack: {
        arity: -4,
        flags: [
          "write",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xadd: {
        arity: -5,
        flags: [
          "write",
          "denyoom",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xautoclaim: {
        arity: -6,
        flags: [
          "write",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xclaim: {
        arity: -6,
        flags: [
          "write",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xdel: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xgroup: {
        arity: -2,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 2,
        keyStop: 2,
        step: 1
      },
      xinfo: {
        arity: -2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 2,
        keyStop: 2,
        step: 1
      },
      xlen: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xpending: {
        arity: -3,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xrange: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xread: {
        arity: -4,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      xreadgroup: {
        arity: -7,
        flags: [
          "write",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      xrevrange: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xsetid: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xtrim: {
        arity: -2,
        flags: [
          "write",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zadd: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zcard: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zcount: {
        arity: 4,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zdiff: {
        arity: -3,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      zdiffstore: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zincrby: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zinter: {
        arity: -3,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      zinterstore: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zlexcount: {
        arity: 4,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zmscore: {
        arity: -3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zpopmax: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zpopmin: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrandmember: {
        arity: -2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrange: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrangebylex: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrangebyscore: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrangestore: {
        arity: -5,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      zrank: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrem: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zremrangebylex: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zremrangebyrank: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zremrangebyscore: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrevrange: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrevrangebylex: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrevrangebyscore: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrevrank: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zscan: {
        arity: -3,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zscore: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zunion: {
        arity: -3,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      zunionstore: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      }
    };
  }
});

// node_modules/redis-commands/index.js
var require_redis_commands = __commonJS({
  "node_modules/redis-commands/index.js"(exports) {
    "use strict";
    var commands = require_commands();
    exports.list = Object.keys(commands);
    var flags = {};
    exports.list.forEach(function(commandName) {
      flags[commandName] = commands[commandName].flags.reduce(function(flags2, flag) {
        flags2[flag] = true;
        return flags2;
      }, {});
    });
    exports.exists = function(commandName) {
      return Boolean(commands[commandName]);
    };
    exports.hasFlag = function(commandName, flag) {
      if (!flags[commandName]) {
        throw new Error("Unknown command " + commandName);
      }
      return Boolean(flags[commandName][flag]);
    };
    exports.getKeyIndexes = function(commandName, args, options) {
      var command = commands[commandName];
      if (!command) {
        throw new Error("Unknown command " + commandName);
      }
      if (!Array.isArray(args)) {
        throw new Error("Expect args to be an array");
      }
      var keys = [];
      var i, keyStart, keyStop, parseExternalKey;
      switch (commandName) {
        case "zunionstore":
        case "zinterstore":
          keys.push(0);
        case "eval":
        case "evalsha":
          keyStop = Number(args[1]) + 2;
          for (i = 2; i < keyStop; i++) {
            keys.push(i);
          }
          break;
        case "sort":
          parseExternalKey = options && options.parseExternalKey;
          keys.push(0);
          for (i = 1; i < args.length - 1; i++) {
            if (typeof args[i] !== "string") {
              continue;
            }
            var directive = args[i].toUpperCase();
            if (directive === "GET") {
              i += 1;
              if (args[i] !== "#") {
                if (parseExternalKey) {
                  keys.push([i, getExternalKeyNameLength(args[i])]);
                } else {
                  keys.push(i);
                }
              }
            } else if (directive === "BY") {
              i += 1;
              if (parseExternalKey) {
                keys.push([i, getExternalKeyNameLength(args[i])]);
              } else {
                keys.push(i);
              }
            } else if (directive === "STORE") {
              i += 1;
              keys.push(i);
            }
          }
          break;
        case "migrate":
          if (args[2] === "") {
            for (i = 5; i < args.length - 1; i++) {
              if (args[i].toUpperCase() === "KEYS") {
                for (var j = i + 1; j < args.length; j++) {
                  keys.push(j);
                }
                break;
              }
            }
          } else {
            keys.push(2);
          }
          break;
        case "xreadgroup":
        case "xread":
          for (i = commandName === "xread" ? 0 : 3; i < args.length - 1; i++) {
            if (String(args[i]).toUpperCase() === "STREAMS") {
              for (j = i + 1; j <= i + (args.length - 1 - i) / 2; j++) {
                keys.push(j);
              }
              break;
            }
          }
          break;
        default:
          if (command.step > 0) {
            keyStart = command.keyStart - 1;
            keyStop = command.keyStop > 0 ? command.keyStop : args.length + command.keyStop + 1;
            for (i = keyStart; i < keyStop; i += command.step) {
              keys.push(i);
            }
          }
          break;
      }
      return keys;
    };
    function getExternalKeyNameLength(key) {
      if (typeof key !== "string") {
        key = String(key);
      }
      var hashPos = key.indexOf("->");
      return hashPos === -1 ? key.length : hashPos;
    }
  }
});

// node_modules/redis/lib/debug.js
var require_debug = __commonJS({
  "node_modules/redis/lib/debug.js"(exports, module) {
    "use strict";
    var index = require_redis();
    function debug() {
      if (index.debug_mode) {
        var data = Array.prototype.slice.call(arguments);
        data.unshift((/* @__PURE__ */ new Date()).toISOString());
        console.error.apply(null, data);
      }
    }
    module.exports = debug;
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/redis/lib/createClient.js
var require_createClient = __commonJS({
  "node_modules/redis/lib/createClient.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var URL = require_url();
    module.exports = function createClient(port_arg, host_arg, options) {
      if (typeof port_arg === "number" || typeof port_arg === "string" && /^\d+$/.test(port_arg)) {
        var host;
        if (typeof host_arg === "string") {
          host = host_arg;
        } else {
          if (options && host_arg) {
            throw new TypeError("Unknown type of connection in createClient()");
          }
          options = options || host_arg;
        }
        options = utils.clone(options);
        options.host = host || options.host;
        options.port = port_arg;
      } else if (typeof port_arg === "string" || port_arg && port_arg.url) {
        options = utils.clone(port_arg.url ? port_arg : host_arg || options);
        var url = port_arg.url || port_arg;
        var parsed = URL.parse(url, true, true);
        if (parsed.slashes) {
          if (parsed.auth) {
            var columnIndex = parsed.auth.indexOf(":");
            options.password = parsed.auth.slice(columnIndex + 1);
            if (columnIndex > 0) {
              options.user = parsed.auth.slice(0, columnIndex);
            }
          }
          if (parsed.protocol) {
            if (parsed.protocol === "rediss:") {
              options.tls = options.tls || {};
            } else if (parsed.protocol !== "redis:") {
              console.warn('node_redis: WARNING: You passed "' + parsed.protocol.substring(0, parsed.protocol.length - 1) + '" as protocol instead of the "redis" protocol!');
            }
          }
          if (parsed.pathname && parsed.pathname !== "/") {
            options.db = parsed.pathname.substr(1);
          }
          if (parsed.hostname) {
            options.host = parsed.hostname;
          }
          if (parsed.port) {
            options.port = parsed.port;
          }
          if (parsed.search !== "") {
            var elem;
            for (elem in parsed.query) {
              if (elem in options) {
                if (options[elem] === parsed.query[elem]) {
                  console.warn("node_redis: WARNING: You passed the " + elem + " option twice!");
                } else {
                  throw new RangeError("The " + elem + " option is added twice and does not match");
                }
              }
              options[elem] = parsed.query[elem];
            }
          }
        } else if (parsed.hostname) {
          throw new RangeError('The redis url must begin with slashes "//" or contain slashes after the redis protocol');
        } else {
          options.path = url;
        }
      } else if (typeof port_arg === "object" || port_arg === void 0) {
        options = utils.clone(port_arg || options);
        options.host = options.host || host_arg;
        if (port_arg && arguments.length !== 1) {
          throw new TypeError("Too many arguments passed to createClient. Please only pass the options object");
        }
      }
      if (!options) {
        throw new TypeError("Unknown type of connection in createClient()");
      }
      return options;
    };
  }
});

// node_modules/redis/lib/multi.js
var require_multi = __commonJS({
  "node_modules/redis/lib/multi.js"(exports, module) {
    "use strict";
    var Queue = require_denque();
    var utils = require_utils();
    var Command = require_command();
    function Multi(client, args) {
      this._client = client;
      this.queue = new Queue();
      var command, tmp_args;
      if (args) {
        for (var i = 0; i < args.length; i++) {
          command = args[i][0];
          tmp_args = args[i].slice(1);
          if (Array.isArray(command)) {
            this[command[0]].apply(this, command.slice(1).concat(tmp_args));
          } else {
            this[command].apply(this, tmp_args);
          }
        }
      }
    }
    function pipeline_transaction_command(self, command_obj, index) {
      var tmp = command_obj.callback;
      command_obj.callback = function(err, reply) {
        if (err && index !== -1) {
          if (tmp) {
            tmp(err);
          }
          err.position = index;
          self.errors.push(err);
        }
        self.wants_buffers[index] = command_obj.buffer_args;
        command_obj.callback = tmp;
      };
      self._client.internal_send_command(command_obj);
    }
    Multi.prototype.exec_atomic = Multi.prototype.EXEC_ATOMIC = Multi.prototype.execAtomic = function exec_atomic(callback) {
      if (this.queue.length < 2) {
        return this.exec_batch(callback);
      }
      return this.exec(callback);
    };
    function multi_callback(self, err, replies) {
      var i = 0, command_obj;
      if (err) {
        err.errors = self.errors;
        if (self.callback) {
          self.callback(err);
        } else if (err.code !== "CONNECTION_BROKEN") {
          self._client.emit("error", err);
        }
        return;
      }
      if (replies) {
        while (command_obj = self.queue.shift()) {
          if (replies[i] instanceof Error) {
            var match = replies[i].message.match(utils.err_code);
            if (match) {
              replies[i].code = match[1];
            }
            replies[i].command = command_obj.command.toUpperCase();
            if (typeof command_obj.callback === "function") {
              command_obj.callback(replies[i]);
            }
          } else {
            replies[i] = self._client.handle_reply(replies[i], command_obj.command, self.wants_buffers[i]);
            if (typeof command_obj.callback === "function") {
              command_obj.callback(null, replies[i]);
            }
          }
          i++;
        }
      }
      if (self.callback) {
        self.callback(null, replies);
      }
    }
    Multi.prototype.exec_transaction = function exec_transaction(callback) {
      if (this.monitoring || this._client.monitoring) {
        var err = new RangeError(
          "Using transaction with a client that is in monitor mode does not work due to faulty return values of Redis."
        );
        err.command = "EXEC";
        err.code = "EXECABORT";
        return utils.reply_in_order(this._client, callback, err);
      }
      var self = this;
      var len = self.queue.length;
      self.errors = [];
      self.callback = callback;
      self._client.cork();
      self.wants_buffers = new Array(len);
      pipeline_transaction_command(self, new Command("multi", []), -1);
      for (var index = 0; index < len; index++) {
        pipeline_transaction_command(self, self.queue.get(index), index);
      }
      self._client.internal_send_command(new Command("exec", [], function(err2, replies) {
        multi_callback(self, err2, replies);
      }));
      self._client.uncork();
      return !self._client.should_buffer;
    };
    function batch_callback(self, cb, i) {
      return function batch_callback2(err, res) {
        if (err) {
          self.results[i] = err;
          self.results[i].position = i;
        } else {
          self.results[i] = res;
        }
        cb(err, res);
      };
    }
    Multi.prototype.exec = Multi.prototype.EXEC = Multi.prototype.exec_batch = function exec_batch(callback) {
      var self = this;
      var len = self.queue.length;
      var index = 0;
      var command_obj;
      if (len === 0) {
        utils.reply_in_order(self._client, callback, null, []);
        return !self._client.should_buffer;
      }
      self._client.cork();
      if (!callback) {
        while (command_obj = self.queue.shift()) {
          self._client.internal_send_command(command_obj);
        }
        self._client.uncork();
        return !self._client.should_buffer;
      }
      var callback_without_own_cb = function(err, res) {
        if (err) {
          self.results.push(err);
          var i = self.results.length - 1;
          self.results[i].position = i;
        } else {
          self.results.push(res);
        }
      };
      var last_callback = function(cb) {
        return function(err, res) {
          cb(err, res);
          callback(null, self.results);
        };
      };
      self.results = [];
      while (command_obj = self.queue.shift()) {
        if (typeof command_obj.callback === "function") {
          command_obj.callback = batch_callback(self, command_obj.callback, index);
        } else {
          command_obj.callback = callback_without_own_cb;
        }
        if (typeof callback === "function" && index === len - 1) {
          command_obj.callback = last_callback(command_obj.callback);
        }
        this._client.internal_send_command(command_obj);
        index++;
      }
      self._client.uncork();
      return !self._client.should_buffer;
    };
    module.exports = Multi;
  }
});

// node_modules/redis/lib/individualCommands.js
var require_individualCommands = __commonJS({
  "node_modules/redis/lib/individualCommands.js"() {
    "use strict";
    var utils = require_utils();
    var debug = require_debug();
    var Multi = require_multi();
    var Command = require_command();
    var no_password_is_set = /no password is set|called without any password configured/;
    var loading = /LOADING/;
    var RedisClient = require_redis().RedisClient;
    RedisClient.prototype.multi = RedisClient.prototype.MULTI = function multi(args) {
      var multi2 = new Multi(this, args);
      multi2.exec = multi2.EXEC = multi2.exec_transaction;
      return multi2;
    };
    RedisClient.prototype.batch = RedisClient.prototype.BATCH = function batch(args) {
      return new Multi(this, args);
    };
    function select_callback(self, db, callback) {
      return function(err, res) {
        if (err === null) {
          self.selected_db = db;
        }
        utils.callback_or_emit(self, callback, err, res);
      };
    }
    RedisClient.prototype.select = RedisClient.prototype.SELECT = function select(db, callback) {
      return this.internal_send_command(new Command("select", [db], select_callback(this, db, callback)));
    };
    Multi.prototype.select = Multi.prototype.SELECT = function select(db, callback) {
      this.queue.push(new Command("select", [db], select_callback(this._client, db, callback)));
      return this;
    };
    RedisClient.prototype.monitor = RedisClient.prototype.MONITOR = function monitor(callback) {
      var self = this;
      var call_on_write = function() {
        self.monitoring = true;
      };
      return this.internal_send_command(new Command("monitor", [], callback, call_on_write));
    };
    Multi.prototype.monitor = Multi.prototype.MONITOR = function monitor(callback) {
      if (this.exec !== this.exec_transaction) {
        var self = this;
        var call_on_write = function() {
          self._client.monitoring = true;
        };
        this.queue.push(new Command("monitor", [], callback, call_on_write));
        return this;
      }
      this.monitoring = true;
      return this;
    };
    function quit_callback(self, callback) {
      return function(err, res) {
        if (err && err.code === "NR_CLOSED") {
          err = null;
          res = "OK";
        }
        utils.callback_or_emit(self, callback, err, res);
        if (self.stream.writable) {
          self.stream.destroy();
        }
      };
    }
    RedisClient.prototype.QUIT = RedisClient.prototype.quit = function quit(callback) {
      var backpressure_indicator = this.internal_send_command(new Command("quit", [], quit_callback(this, callback)));
      this.closing = true;
      this.ready = false;
      return backpressure_indicator;
    };
    Multi.prototype.QUIT = Multi.prototype.quit = function quit(callback) {
      var self = this._client;
      var call_on_write = function() {
        self.closing = true;
        self.ready = false;
      };
      this.queue.push(new Command("quit", [], quit_callback(self, callback), call_on_write));
      return this;
    };
    function info_callback(self, callback) {
      return function(err, res) {
        if (res) {
          var obj = {};
          var lines = res.toString().split("\r\n");
          var line, parts, sub_parts;
          for (var i = 0; i < lines.length; i++) {
            parts = lines[i].split(":");
            if (parts[1]) {
              if (parts[0].indexOf("db") === 0) {
                sub_parts = parts[1].split(",");
                obj[parts[0]] = {};
                while (line = sub_parts.pop()) {
                  line = line.split("=");
                  obj[parts[0]][line[0]] = +line[1];
                }
              } else {
                obj[parts[0]] = parts[1];
              }
            }
          }
          obj.versions = [];
          if (obj.redis_version) {
            obj.redis_version.split(".").forEach(function(num) {
              obj.versions.push(+num);
            });
          }
          self.server_info = obj;
        } else {
          self.server_info = {};
        }
        utils.callback_or_emit(self, callback, err, res);
      };
    }
    RedisClient.prototype.info = RedisClient.prototype.INFO = function info(section, callback) {
      var args = [];
      if (typeof section === "function") {
        callback = section;
      } else if (section !== void 0) {
        args = Array.isArray(section) ? section : [section];
      }
      return this.internal_send_command(new Command("info", args, info_callback(this, callback)));
    };
    Multi.prototype.info = Multi.prototype.INFO = function info(section, callback) {
      var args = [];
      if (typeof section === "function") {
        callback = section;
      } else if (section !== void 0) {
        args = Array.isArray(section) ? section : [section];
      }
      this.queue.push(new Command("info", args, info_callback(this._client, callback)));
      return this;
    };
    function auth_callback(self, pass, user, callback) {
      return function(err, res) {
        if (err) {
          if (no_password_is_set.test(err.message)) {
            self.warn("Warning: Redis server does not require a password, but a password was supplied.");
            err = null;
            res = "OK";
          } else if (loading.test(err.message)) {
            debug("Redis still loading, trying to authenticate later");
            setTimeout(function() {
              self.auth(pass, user, callback);
            }, 100);
            return;
          }
        }
        utils.callback_or_emit(self, callback, err, res);
      };
    }
    RedisClient.prototype.auth = RedisClient.prototype.AUTH = function auth(pass, user, callback) {
      debug("Sending auth to " + this.address + " id " + this.connection_id);
      if (user instanceof Function) {
        callback = user;
        user = null;
      }
      this.auth_pass = pass;
      this.auth_user = user;
      var ready = this.ready;
      this.ready = ready || this.offline_queue.length === 0;
      var tmp = this.internal_send_command(new Command("auth", user ? [user, pass] : [pass], auth_callback(this, pass, user, callback)));
      this.ready = ready;
      return tmp;
    };
    Multi.prototype.auth = Multi.prototype.AUTH = function auth(pass, user, callback) {
      debug("Sending auth to " + this.address + " id " + this.connection_id);
      if (user instanceof Function) {
        callback = user;
        user = null;
      }
      this.auth_pass = pass;
      this.auth_user = user;
      this.queue.push(new Command("auth", user ? [user, pass] : [pass], auth_callback(this._client, pass, user, callback)));
      return this;
    };
    RedisClient.prototype.client = RedisClient.prototype.CLIENT = function client() {
      var arr, len = arguments.length, callback, i = 0;
      if (Array.isArray(arguments[0])) {
        arr = arguments[0];
        callback = arguments[1];
      } else if (Array.isArray(arguments[1])) {
        if (len === 3) {
          callback = arguments[2];
        }
        len = arguments[1].length;
        arr = new Array(len + 1);
        arr[0] = arguments[0];
        for (; i < len; i += 1) {
          arr[i + 1] = arguments[1][i];
        }
      } else {
        len = arguments.length;
        if (len !== 0 && (typeof arguments[len - 1] === "function" || typeof arguments[len - 1] === "undefined")) {
          len--;
          callback = arguments[len];
        }
        arr = new Array(len);
        for (; i < len; i += 1) {
          arr[i] = arguments[i];
        }
      }
      var self = this;
      var call_on_write = void 0;
      if (arr.length === 2 && arr[0].toString().toUpperCase() === "REPLY") {
        var reply_on_off = arr[1].toString().toUpperCase();
        if (reply_on_off === "ON" || reply_on_off === "OFF" || reply_on_off === "SKIP") {
          call_on_write = function() {
            self.reply = reply_on_off;
          };
        }
      }
      return this.internal_send_command(new Command("client", arr, callback, call_on_write));
    };
    Multi.prototype.client = Multi.prototype.CLIENT = function client() {
      var arr, len = arguments.length, callback, i = 0;
      if (Array.isArray(arguments[0])) {
        arr = arguments[0];
        callback = arguments[1];
      } else if (Array.isArray(arguments[1])) {
        if (len === 3) {
          callback = arguments[2];
        }
        len = arguments[1].length;
        arr = new Array(len + 1);
        arr[0] = arguments[0];
        for (; i < len; i += 1) {
          arr[i + 1] = arguments[1][i];
        }
      } else {
        len = arguments.length;
        if (len !== 0 && (typeof arguments[len - 1] === "function" || typeof arguments[len - 1] === "undefined")) {
          len--;
          callback = arguments[len];
        }
        arr = new Array(len);
        for (; i < len; i += 1) {
          arr[i] = arguments[i];
        }
      }
      var self = this._client;
      var call_on_write = void 0;
      if (arr.length === 2 && arr[0].toString().toUpperCase() === "REPLY") {
        var reply_on_off = arr[1].toString().toUpperCase();
        if (reply_on_off === "ON" || reply_on_off === "OFF" || reply_on_off === "SKIP") {
          call_on_write = function() {
            self.reply = reply_on_off;
          };
        }
      }
      this.queue.push(new Command("client", arr, callback, call_on_write));
      return this;
    };
    RedisClient.prototype.hmset = RedisClient.prototype.HMSET = function hmset() {
      var arr, len = arguments.length, callback, i = 0;
      if (Array.isArray(arguments[0])) {
        arr = arguments[0];
        callback = arguments[1];
      } else if (Array.isArray(arguments[1])) {
        if (len === 3) {
          callback = arguments[2];
        }
        len = arguments[1].length;
        arr = new Array(len + 1);
        arr[0] = arguments[0];
        for (; i < len; i += 1) {
          arr[i + 1] = arguments[1][i];
        }
      } else if (typeof arguments[1] === "object" && (arguments.length === 2 || arguments.length === 3 && (typeof arguments[2] === "function" || typeof arguments[2] === "undefined"))) {
        arr = [arguments[0]];
        for (var field in arguments[1]) {
          arr.push(field, arguments[1][field]);
        }
        callback = arguments[2];
      } else {
        len = arguments.length;
        if (len !== 0 && (typeof arguments[len - 1] === "function" || typeof arguments[len - 1] === "undefined")) {
          len--;
          callback = arguments[len];
        }
        arr = new Array(len);
        for (; i < len; i += 1) {
          arr[i] = arguments[i];
        }
      }
      return this.internal_send_command(new Command("hmset", arr, callback));
    };
    Multi.prototype.hmset = Multi.prototype.HMSET = function hmset() {
      var arr, len = arguments.length, callback, i = 0;
      if (Array.isArray(arguments[0])) {
        arr = arguments[0];
        callback = arguments[1];
      } else if (Array.isArray(arguments[1])) {
        if (len === 3) {
          callback = arguments[2];
        }
        len = arguments[1].length;
        arr = new Array(len + 1);
        arr[0] = arguments[0];
        for (; i < len; i += 1) {
          arr[i + 1] = arguments[1][i];
        }
      } else if (typeof arguments[1] === "object" && (arguments.length === 2 || arguments.length === 3 && (typeof arguments[2] === "function" || typeof arguments[2] === "undefined"))) {
        arr = [arguments[0]];
        for (var field in arguments[1]) {
          arr.push(field, arguments[1][field]);
        }
        callback = arguments[2];
      } else {
        len = arguments.length;
        if (len !== 0 && (typeof arguments[len - 1] === "function" || typeof arguments[len - 1] === "undefined")) {
          len--;
          callback = arguments[len];
        }
        arr = new Array(len);
        for (; i < len; i += 1) {
          arr[i] = arguments[i];
        }
      }
      this.queue.push(new Command("hmset", arr, callback));
      return this;
    };
    RedisClient.prototype.subscribe = RedisClient.prototype.SUBSCRIBE = function subscribe() {
      var arr, len = arguments.length, callback, i = 0;
      if (Array.isArray(arguments[0])) {
        arr = arguments[0].slice(0);
        callback = arguments[1];
      } else {
        len = arguments.length;
        if (len !== 0 && (typeof arguments[len - 1] === "function" || typeof arguments[len - 1] === "undefined")) {
          len--;
          callback = arguments[len];
        }
        arr = new Array(len);
        for (; i < len; i += 1) {
          arr[i] = arguments[i];
        }
      }
      var self = this;
      var call_on_write = function() {
        self.pub_sub_mode = self.pub_sub_mode || self.command_queue.length + 1;
      };
      return this.internal_send_command(new Command("subscribe", arr, callback, call_on_write));
    };
    Multi.prototype.subscribe = Multi.prototype.SUBSCRIBE = function subscribe() {
      var arr, len = arguments.length, callback, i = 0;
      if (Array.isArray(arguments[0])) {
        arr = arguments[0].slice(0);
        callback = arguments[1];
      } else {
        len = arguments.length;
        if (len !== 0 && (typeof arguments[len - 1] === "function" || typeof arguments[len - 1] === "undefined")) {
          len--;
          callback = arguments[len];
        }
        arr = new Array(len);
        for (; i < len; i += 1) {
          arr[i] = arguments[i];
        }
      }
      var self = this._client;
      var call_on_write = function() {
        self.pub_sub_mode = self.pub_sub_mode || self.command_queue.length + 1;
      };
      this.queue.push(new Command("subscribe", arr, callback, call_on_write));
      return this;
    };
    RedisClient.prototype.unsubscribe = RedisClient.prototype.UNSUBSCRIBE = function unsubscribe() {
      var arr, len = arguments.length, callback, i = 0;
      if (Array.isArray(arguments[0])) {
        arr = arguments[0].slice(0);
        callback = arguments[1];
      } else {
        len = arguments.length;
        if (len !== 0 && (typeof arguments[len - 1] === "function" || typeof arguments[len - 1] === "undefined")) {
          len--;
          callback = arguments[len];
        }
        arr = new Array(len);
        for (; i < len; i += 1) {
          arr[i] = arguments[i];
        }
      }
      var self = this;
      var call_on_write = function() {
        self.pub_sub_mode = self.pub_sub_mode || self.command_queue.length + 1;
      };
      return this.internal_send_command(new Command("unsubscribe", arr, callback, call_on_write));
    };
    Multi.prototype.unsubscribe = Multi.prototype.UNSUBSCRIBE = function unsubscribe() {
      var arr, len = arguments.length, callback, i = 0;
      if (Array.isArray(arguments[0])) {
        arr = arguments[0].slice(0);
        callback = arguments[1];
      } else {
        len = arguments.length;
        if (len !== 0 && (typeof arguments[len - 1] === "function" || typeof arguments[len - 1] === "undefined")) {
          len--;
          callback = arguments[len];
        }
        arr = new Array(len);
        for (; i < len; i += 1) {
          arr[i] = arguments[i];
        }
      }
      var self = this._client;
      var call_on_write = function() {
        self.pub_sub_mode = self.pub_sub_mode || self.command_queue.length + 1;
      };
      this.queue.push(new Command("unsubscribe", arr, callback, call_on_write));
      return this;
    };
    RedisClient.prototype.psubscribe = RedisClient.prototype.PSUBSCRIBE = function psubscribe() {
      var arr, len = arguments.length, callback, i = 0;
      if (Array.isArray(arguments[0])) {
        arr = arguments[0].slice(0);
        callback = arguments[1];
      } else {
        len = arguments.length;
        if (len !== 0 && (typeof arguments[len - 1] === "function" || typeof arguments[len - 1] === "undefined")) {
          len--;
          callback = arguments[len];
        }
        arr = new Array(len);
        for (; i < len; i += 1) {
          arr[i] = arguments[i];
        }
      }
      var self = this;
      var call_on_write = function() {
        self.pub_sub_mode = self.pub_sub_mode || self.command_queue.length + 1;
      };
      return this.internal_send_command(new Command("psubscribe", arr, callback, call_on_write));
    };
    Multi.prototype.psubscribe = Multi.prototype.PSUBSCRIBE = function psubscribe() {
      var arr, len = arguments.length, callback, i = 0;
      if (Array.isArray(arguments[0])) {
        arr = arguments[0].slice(0);
        callback = arguments[1];
      } else {
        len = arguments.length;
        if (len !== 0 && (typeof arguments[len - 1] === "function" || typeof arguments[len - 1] === "undefined")) {
          len--;
          callback = arguments[len];
        }
        arr = new Array(len);
        for (; i < len; i += 1) {
          arr[i] = arguments[i];
        }
      }
      var self = this._client;
      var call_on_write = function() {
        self.pub_sub_mode = self.pub_sub_mode || self.command_queue.length + 1;
      };
      this.queue.push(new Command("psubscribe", arr, callback, call_on_write));
      return this;
    };
    RedisClient.prototype.punsubscribe = RedisClient.prototype.PUNSUBSCRIBE = function punsubscribe() {
      var arr, len = arguments.length, callback, i = 0;
      if (Array.isArray(arguments[0])) {
        arr = arguments[0].slice(0);
        callback = arguments[1];
      } else {
        len = arguments.length;
        if (len !== 0 && (typeof arguments[len - 1] === "function" || typeof arguments[len - 1] === "undefined")) {
          len--;
          callback = arguments[len];
        }
        arr = new Array(len);
        for (; i < len; i += 1) {
          arr[i] = arguments[i];
        }
      }
      var self = this;
      var call_on_write = function() {
        self.pub_sub_mode = self.pub_sub_mode || self.command_queue.length + 1;
      };
      return this.internal_send_command(new Command("punsubscribe", arr, callback, call_on_write));
    };
    Multi.prototype.punsubscribe = Multi.prototype.PUNSUBSCRIBE = function punsubscribe() {
      var arr, len = arguments.length, callback, i = 0;
      if (Array.isArray(arguments[0])) {
        arr = arguments[0].slice(0);
        callback = arguments[1];
      } else {
        len = arguments.length;
        if (len !== 0 && (typeof arguments[len - 1] === "function" || typeof arguments[len - 1] === "undefined")) {
          len--;
          callback = arguments[len];
        }
        arr = new Array(len);
        for (; i < len; i += 1) {
          arr[i] = arguments[i];
        }
      }
      var self = this._client;
      var call_on_write = function() {
        self.pub_sub_mode = self.pub_sub_mode || self.command_queue.length + 1;
      };
      this.queue.push(new Command("punsubscribe", arr, callback, call_on_write));
      return this;
    };
  }
});

// node_modules/redis/lib/extendedApi.js
var require_extendedApi = __commonJS({
  "node_modules/redis/lib/extendedApi.js"() {
    "use strict";
    var utils = require_utils();
    var debug = require_debug();
    var RedisClient = require_redis().RedisClient;
    var Command = require_command();
    var noop = function() {
    };
    RedisClient.prototype.send_command = RedisClient.prototype.sendCommand = function(command, args, callback) {
      if (typeof command !== "string") {
        throw new TypeError('Wrong input type "' + (command !== null && command !== void 0 ? command.constructor.name : command) + '" for command name');
      }
      command = command.toLowerCase();
      if (!Array.isArray(args)) {
        if (args === void 0 || args === null) {
          args = [];
        } else if (typeof args === "function" && callback === void 0) {
          callback = args;
          args = [];
        } else {
          throw new TypeError('Wrong input type "' + args.constructor.name + '" for args');
        }
      }
      if (typeof callback !== "function" && callback !== void 0) {
        throw new TypeError('Wrong input type "' + (callback !== null ? callback.constructor.name : "null") + '" for callback function');
      }
      if (command === "multi" || typeof this[command] !== "function") {
        return this.internal_send_command(new Command(command, args, callback));
      }
      if (typeof callback === "function") {
        args = args.concat([callback]);
      }
      return this[command].apply(this, args);
    };
    RedisClient.prototype.end = function(flush) {
      if (flush) {
        this.flush_and_error({
          message: "Connection forcefully ended and command aborted.",
          code: "NR_CLOSED"
        });
      } else if (arguments.length === 0) {
        this.warn(
          "Using .end() without the flush parameter is deprecated and throws from v.3.0.0 on.\nPlease check the doku (https://github.com/NodeRedis/node_redis) and explictly use flush."
        );
      }
      if (this.retry_timer) {
        clearTimeout(this.retry_timer);
        this.retry_timer = null;
      }
      this.stream.removeAllListeners();
      this.stream.on("error", noop);
      this.connected = false;
      this.ready = false;
      this.closing = true;
      return this.stream.destroySoon();
    };
    RedisClient.prototype.unref = function() {
      if (this.connected) {
        debug("Unref'ing the socket connection");
        this.stream.unref();
      } else {
        debug("Not connected yet, will unref later");
        this.once("connect", function() {
          this.unref();
        });
      }
    };
    RedisClient.prototype.duplicate = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      var existing_options = utils.clone(this.options);
      options = utils.clone(options);
      for (var elem in options) {
        existing_options[elem] = options[elem];
      }
      var client = new RedisClient(existing_options);
      client.selected_db = options.db || this.selected_db;
      if (typeof callback === "function") {
        var ready_listener = function() {
          callback(null, client);
          client.removeAllListeners(error_listener);
        };
        var error_listener = function(err) {
          callback(err);
          client.end(true);
        };
        client.once("ready", ready_listener);
        client.once("error", error_listener);
        return;
      }
      return client;
    };
  }
});

// node_modules/redis/lib/commands.js
var require_commands2 = __commonJS({
  "node_modules/redis/lib/commands.js"(exports, module) {
    "use strict";
    var commands = require_redis_commands();
    var Multi = require_multi();
    var RedisClient = require_redis().RedisClient;
    var Command = require_command();
    var addCommand = function(command) {
      var commandName = command.replace(/(?:^([0-9])|[^a-zA-Z0-9_$])/g, "_$1");
      if (!RedisClient.prototype[command]) {
        RedisClient.prototype[command.toUpperCase()] = RedisClient.prototype[command] = function() {
          var arr;
          var len = arguments.length;
          var callback;
          var i = 0;
          if (Array.isArray(arguments[0])) {
            arr = arguments[0];
            if (len === 2) {
              callback = arguments[1];
            }
          } else if (len > 1 && Array.isArray(arguments[1])) {
            if (len === 3) {
              callback = arguments[2];
            }
            len = arguments[1].length;
            arr = new Array(len + 1);
            arr[0] = arguments[0];
            for (; i < len; i += 1) {
              arr[i + 1] = arguments[1][i];
            }
          } else {
            if (len !== 0 && (typeof arguments[len - 1] === "function" || typeof arguments[len - 1] === "undefined")) {
              len--;
              callback = arguments[len];
            }
            arr = new Array(len);
            for (; i < len; i += 1) {
              arr[i] = arguments[i];
            }
          }
          return this.internal_send_command(new Command(command, arr, callback));
        };
        if (commandName !== command) {
          RedisClient.prototype[commandName.toUpperCase()] = RedisClient.prototype[commandName] = RedisClient.prototype[command];
        }
        Object.defineProperty(RedisClient.prototype[command], "name", {
          value: commandName
        });
      }
      if (!Multi.prototype[command]) {
        Multi.prototype[command.toUpperCase()] = Multi.prototype[command] = function() {
          var arr;
          var len = arguments.length;
          var callback;
          var i = 0;
          if (Array.isArray(arguments[0])) {
            arr = arguments[0];
            if (len === 2) {
              callback = arguments[1];
            }
          } else if (len > 1 && Array.isArray(arguments[1])) {
            if (len === 3) {
              callback = arguments[2];
            }
            len = arguments[1].length;
            arr = new Array(len + 1);
            arr[0] = arguments[0];
            for (; i < len; i += 1) {
              arr[i + 1] = arguments[1][i];
            }
          } else {
            if (len !== 0 && (typeof arguments[len - 1] === "function" || typeof arguments[len - 1] === "undefined")) {
              len--;
              callback = arguments[len];
            }
            arr = new Array(len);
            for (; i < len; i += 1) {
              arr[i] = arguments[i];
            }
          }
          this.queue.push(new Command(command, arr, callback));
          return this;
        };
        if (commandName !== command) {
          Multi.prototype[commandName.toUpperCase()] = Multi.prototype[commandName] = Multi.prototype[command];
        }
        Object.defineProperty(Multi.prototype[command], "name", {
          value: commandName
        });
      }
    };
    commands.list.forEach(addCommand);
    module.exports = addCommand;
  }
});

// node_modules/redis/index.js
var require_redis = __commonJS({
  "node_modules/redis/index.js"(exports) {
    "use strict";
    var net = require_net();
    var tls = require_tls();
    var util = require_util();
    var utils = require_utils();
    var Command = require_command();
    var Queue = require_denque();
    var errorClasses = require_customErrors();
    var EventEmitter = require_events();
    var Parser = require_redis_parser();
    var RedisErrors = require_redis_errors();
    var commands = require_redis_commands();
    var debug = require_debug();
    var unifyOptions = require_createClient();
    var SUBSCRIBE_COMMANDS = {
      subscribe: true,
      unsubscribe: true,
      psubscribe: true,
      punsubscribe: true
    };
    function noop() {
    }
    function handle_detect_buffers_reply(reply, command, buffer_args) {
      if (buffer_args === false || this.message_buffers) {
        reply = utils.reply_to_strings(reply);
      }
      if (command === "hgetall") {
        reply = utils.reply_to_object(reply);
      }
      return reply;
    }
    exports.debug_mode = /\bredis\b/i.test(process.env.NODE_DEBUG);
    function RedisClient(options, stream) {
      options = utils.clone(options);
      EventEmitter.call(this);
      var cnx_options = {};
      var self = this;
      for (var tls_option in options.tls) {
        cnx_options[tls_option] = options.tls[tls_option];
        if (tls_option === "port" || tls_option === "host" || tls_option === "path" || tls_option === "family") {
          options[tls_option] = options.tls[tls_option];
        }
      }
      if (stream) {
        options.stream = stream;
        this.address = '"Private stream"';
      } else if (options.path) {
        cnx_options.path = options.path;
        this.address = options.path;
      } else {
        cnx_options.port = +options.port || 6379;
        cnx_options.host = options.host || "127.0.0.1";
        cnx_options.family = !options.family && net.isIP(cnx_options.host) || (options.family === "IPv6" ? 6 : 4);
        this.address = cnx_options.host + ":" + cnx_options.port;
      }
      this.connection_options = cnx_options;
      this.connection_id = RedisClient.connection_id++;
      this.connected = false;
      this.ready = false;
      if (options.socket_keepalive === void 0) {
        options.socket_keepalive = true;
      }
      if (options.socket_initial_delay === void 0) {
        options.socket_initial_delay = 0;
      }
      for (var command in options.rename_commands) {
        options.rename_commands[command.toLowerCase()] = options.rename_commands[command];
      }
      options.return_buffers = !!options.return_buffers;
      options.detect_buffers = !!options.detect_buffers;
      if (options.return_buffers && options.detect_buffers) {
        self.warn("WARNING: You activated return_buffers and detect_buffers at the same time. The return value is always going to be a buffer.");
        options.detect_buffers = false;
      }
      if (options.detect_buffers) {
        this.handle_reply = handle_detect_buffers_reply;
      }
      this.should_buffer = false;
      this.command_queue = new Queue();
      this.offline_queue = new Queue();
      this.pipeline_queue = new Queue();
      this.connect_timeout = +options.connect_timeout || 36e5;
      this.enable_offline_queue = options.enable_offline_queue === false ? false : true;
      this.initialize_retry_vars();
      this.pub_sub_mode = 0;
      this.subscription_set = {};
      this.monitoring = false;
      this.message_buffers = false;
      this.closing = false;
      this.server_info = {};
      this.auth_pass = options.auth_pass || options.password;
      this.auth_user = options.auth_user || options.user;
      this.selected_db = options.db;
      this.fire_strings = true;
      this.pipeline = false;
      this.sub_commands_left = 0;
      this.times_connected = 0;
      this.buffers = options.return_buffers || options.detect_buffers;
      this.options = options;
      this.reply = "ON";
      this.create_stream();
      this.on("newListener", function(event) {
        if ((event === "message_buffer" || event === "pmessage_buffer" || event === "messageBuffer" || event === "pmessageBuffer") && !this.buffers && !this.message_buffers) {
          this.reply_parser.optionReturnBuffers = true;
          this.message_buffers = true;
          this.handle_reply = handle_detect_buffers_reply;
        }
      });
    }
    util.inherits(RedisClient, EventEmitter);
    RedisClient.connection_id = 0;
    function create_parser(self) {
      return new Parser({
        returnReply: function(data) {
          self.return_reply(data);
        },
        returnError: function(err) {
          self.return_error(err);
        },
        returnFatalError: function(err) {
          err.message += ". Please report this.";
          self.ready = false;
          self.flush_and_error({
            message: "Fatal error encountered. Command aborted.",
            code: "NR_FATAL"
          }, {
            error: err,
            queues: ["command_queue"]
          });
          self.emit("error", err);
          self.create_stream();
        },
        returnBuffers: self.buffers || self.message_buffers,
        stringNumbers: self.options.string_numbers || false
      });
    }
    RedisClient.prototype.create_stream = function() {
      var self = this;
      this.reply_parser = create_parser(this);
      if (this.options.stream) {
        if (this.stream) {
          return;
        }
        this.stream = this.options.stream;
      } else {
        if (this.stream) {
          this.stream.removeAllListeners();
          this.stream.destroy();
        }
        if (this.options.tls) {
          this.stream = tls.connect(this.connection_options);
        } else {
          this.stream = net.createConnection(this.connection_options);
        }
      }
      if (this.options.connect_timeout) {
        this.stream.setTimeout(this.connect_timeout, function() {
          self.retry_totaltime = self.connect_timeout;
          self.connection_gone("timeout");
        });
      }
      var connect_event = this.options.tls ? "secureConnect" : "connect";
      this.stream.once(connect_event, function() {
        this.removeAllListeners("timeout");
        self.times_connected++;
        self.on_connect();
      });
      this.stream.on("data", function(buffer_from_socket) {
        debug("Net read " + self.address + " id " + self.connection_id);
        self.reply_parser.execute(buffer_from_socket);
      });
      this.stream.on("error", function(err) {
        self.on_error(err);
      });
      this.stream.once("close", function(hadError) {
        self.connection_gone("close");
      });
      this.stream.once("end", function() {
        self.connection_gone("end");
      });
      this.stream.on("drain", function() {
        self.drain();
      });
      this.stream.setNoDelay();
      if (this.auth_pass !== void 0) {
        this.ready = true;
        this.auth(this.auth_pass, this.auth_user, function(err) {
          if (err && err.code !== "UNCERTAIN_STATE") {
            self.emit("error", err);
          }
        });
        this.ready = false;
      }
    };
    RedisClient.prototype.handle_reply = function(reply, command) {
      if (command === "hgetall") {
        reply = utils.reply_to_object(reply);
      }
      return reply;
    };
    RedisClient.prototype.cork = noop;
    RedisClient.prototype.uncork = noop;
    RedisClient.prototype.initialize_retry_vars = function() {
      this.retry_timer = null;
      this.retry_totaltime = 0;
      this.retry_delay = 200;
      this.retry_backoff = 1.7;
      this.attempts = 1;
    };
    RedisClient.prototype.warn = function(msg) {
      var self = this;
      process.nextTick(function() {
        if (self.listeners("warning").length !== 0) {
          self.emit("warning", msg);
        } else {
          console.warn("node_redis:", msg);
        }
      });
    };
    RedisClient.prototype.flush_and_error = function(error_attributes, options) {
      options = options || {};
      var aggregated_errors = [];
      var queue_names = options.queues || ["command_queue", "offline_queue"];
      for (var i = 0; i < queue_names.length; i++) {
        if (queue_names[i] === "command_queue") {
          error_attributes.message += " It might have been processed.";
        } else {
          error_attributes.message = error_attributes.message.replace(" It might have been processed.", "");
        }
        for (var command_obj = this[queue_names[i]].shift(); command_obj; command_obj = this[queue_names[i]].shift()) {
          var err = new errorClasses.AbortError(error_attributes);
          if (command_obj.error) {
            err.stack = err.stack + command_obj.error.stack.replace(/^Error.*?\n/, "\n");
          }
          err.command = command_obj.command.toUpperCase();
          if (command_obj.args && command_obj.args.length) {
            err.args = command_obj.args;
          }
          if (options.error) {
            err.origin = options.error;
          }
          if (typeof command_obj.callback === "function") {
            command_obj.callback(err);
          } else {
            aggregated_errors.push(err);
          }
        }
      }
      if (exports.debug_mode && aggregated_errors.length) {
        var error;
        if (aggregated_errors.length === 1) {
          error = aggregated_errors[0];
        } else {
          error_attributes.message = error_attributes.message.replace("It", "They").replace(/command/i, "$&s");
          error = new errorClasses.AggregateError(error_attributes);
          error.errors = aggregated_errors;
        }
        this.emit("error", error);
      }
    };
    RedisClient.prototype.on_error = function(err) {
      if (this.closing) {
        return;
      }
      err.message = "Redis connection to " + this.address + " failed - " + err.message;
      debug(err.message);
      this.connected = false;
      this.ready = false;
      if (!this.options.retry_strategy) {
        this.emit("error", err);
      }
      this.connection_gone("error", err);
    };
    RedisClient.prototype.on_connect = function() {
      debug("Stream connected " + this.address + " id " + this.connection_id);
      this.connected = true;
      this.ready = false;
      this.emitted_end = false;
      this.stream.setKeepAlive(this.options.socket_keepalive, this.options.socket_initial_delay);
      this.stream.setTimeout(0);
      this.emit("connect");
      this.initialize_retry_vars();
      if (this.options.no_ready_check) {
        this.on_ready();
      } else {
        this.ready_check();
      }
    };
    RedisClient.prototype.on_ready = function() {
      var self = this;
      debug("on_ready called " + this.address + " id " + this.connection_id);
      this.ready = true;
      this.cork = function() {
        self.pipeline = true;
        if (self.stream.cork) {
          self.stream.cork();
        }
      };
      this.uncork = function() {
        if (self.fire_strings) {
          self.write_strings();
        } else {
          self.write_buffers();
        }
        self.pipeline = false;
        self.fire_strings = true;
        if (self.stream.uncork) {
          self.stream.uncork();
        }
      };
      if (this.selected_db !== void 0) {
        this.internal_send_command(new Command("select", [this.selected_db]));
      }
      if (this.monitoring) {
        this.internal_send_command(new Command("monitor", []));
      }
      var callback_count = Object.keys(this.subscription_set).length;
      if (!this.options.disable_resubscribing && callback_count) {
        var callback = function() {
          callback_count--;
          if (callback_count === 0) {
            self.emit("ready");
          }
        };
        debug("Sending pub/sub on_ready commands");
        for (var key in this.subscription_set) {
          var command = key.slice(0, key.indexOf("_"));
          var args = this.subscription_set[key];
          this[command]([args], callback);
        }
        this.send_offline_queue();
        return;
      }
      this.send_offline_queue();
      this.emit("ready");
    };
    RedisClient.prototype.on_info_cmd = function(err, res) {
      if (err) {
        if (err.message === "ERR unknown command 'info'") {
          this.on_ready();
          return;
        }
        err.message = "Ready check failed: " + err.message;
        this.emit("error", err);
        return;
      }
      if (!res) {
        debug("The info command returned without any data.");
        this.on_ready();
        return;
      }
      if (!this.server_info.loading || this.server_info.loading === "0") {
        if (this.server_info.master_link_status && this.server_info.master_link_status !== "up") {
          this.server_info.loading_eta_seconds = 0.05;
        } else {
          debug("Redis server ready.");
          this.on_ready();
          return;
        }
      }
      var retry_time = +this.server_info.loading_eta_seconds * 1e3;
      if (retry_time > 1e3) {
        retry_time = 1e3;
      }
      debug("Redis server still loading, trying again in " + retry_time);
      setTimeout(function(self) {
        self.ready_check();
      }, retry_time, this);
    };
    RedisClient.prototype.ready_check = function() {
      var self = this;
      debug("Checking server ready state...");
      this.ready = true;
      this.info(function(err, res) {
        self.on_info_cmd(err, res);
      });
      this.ready = false;
    };
    RedisClient.prototype.send_offline_queue = function() {
      for (var command_obj = this.offline_queue.shift(); command_obj; command_obj = this.offline_queue.shift()) {
        debug("Sending offline command: " + command_obj.command);
        this.internal_send_command(command_obj);
      }
      this.drain();
    };
    var retry_connection = function(self, error) {
      debug("Retrying connection...");
      var reconnect_params = {
        delay: self.retry_delay,
        attempt: self.attempts,
        error
      };
      if (self.options.camel_case) {
        reconnect_params.totalRetryTime = self.retry_totaltime;
        reconnect_params.timesConnected = self.times_connected;
      } else {
        reconnect_params.total_retry_time = self.retry_totaltime;
        reconnect_params.times_connected = self.times_connected;
      }
      self.emit("reconnecting", reconnect_params);
      self.retry_totaltime += self.retry_delay;
      self.attempts += 1;
      self.retry_delay = Math.round(self.retry_delay * self.retry_backoff);
      self.create_stream();
      self.retry_timer = null;
    };
    RedisClient.prototype.connection_gone = function(why, error) {
      if (this.retry_timer) {
        return;
      }
      error = error || null;
      debug("Redis connection is gone from " + why + " event.");
      this.connected = false;
      this.ready = false;
      this.cork = noop;
      this.uncork = noop;
      this.pipeline = false;
      this.pub_sub_mode = 0;
      if (!this.emitted_end) {
        this.emit("end");
        this.emitted_end = true;
      }
      if (this.closing) {
        debug("Connection ended by quit / end command, not retrying.");
        this.flush_and_error({
          message: "Stream connection ended and command aborted.",
          code: "NR_CLOSED"
        }, {
          error
        });
        return;
      }
      if (typeof this.options.retry_strategy === "function") {
        var retry_params = {
          attempt: this.attempts,
          error
        };
        if (this.options.camel_case) {
          retry_params.totalRetryTime = this.retry_totaltime;
          retry_params.timesConnected = this.times_connected;
        } else {
          retry_params.total_retry_time = this.retry_totaltime;
          retry_params.times_connected = this.times_connected;
        }
        this.retry_delay = this.options.retry_strategy(retry_params);
        if (typeof this.retry_delay !== "number") {
          if (this.retry_delay instanceof Error) {
            error = this.retry_delay;
          }
          var errorMessage = "Redis connection in broken state: retry aborted.";
          this.flush_and_error({
            message: errorMessage,
            code: "CONNECTION_BROKEN"
          }, {
            error
          });
          var retryError = new Error(errorMessage);
          retryError.code = "CONNECTION_BROKEN";
          if (error) {
            retryError.origin = error;
          }
          this.end(false);
          this.emit("error", retryError);
          return;
        }
      }
      if (this.retry_totaltime >= this.connect_timeout) {
        var message = "Redis connection in broken state: connection timeout exceeded.";
        this.flush_and_error({
          message,
          code: "CONNECTION_BROKEN"
        }, {
          error
        });
        var err = new Error(message);
        err.code = "CONNECTION_BROKEN";
        if (error) {
          err.origin = error;
        }
        this.end(false);
        this.emit("error", err);
        return;
      }
      if (this.options.retry_unfulfilled_commands) {
        this.offline_queue.unshift.apply(this.offline_queue, this.command_queue.toArray());
        this.command_queue.clear();
      } else if (this.command_queue.length !== 0) {
        this.flush_and_error({
          message: "Redis connection lost and command aborted.",
          code: "UNCERTAIN_STATE"
        }, {
          error,
          queues: ["command_queue"]
        });
      }
      if (this.retry_totaltime + this.retry_delay > this.connect_timeout) {
        this.retry_delay = this.connect_timeout - this.retry_totaltime;
      }
      debug("Retry connection in " + this.retry_delay + " ms");
      this.retry_timer = setTimeout(retry_connection, this.retry_delay, this, error);
    };
    RedisClient.prototype.return_error = function(err) {
      var command_obj = this.command_queue.shift();
      if (command_obj.error) {
        err.stack = command_obj.error.stack.replace(/^Error.*?\n/, "ReplyError: " + err.message + "\n");
      }
      err.command = command_obj.command.toUpperCase();
      if (command_obj.args && command_obj.args.length) {
        err.args = command_obj.args;
      }
      if (this.pub_sub_mode > 1) {
        this.pub_sub_mode--;
      }
      var match = err.message.match(utils.err_code);
      if (match) {
        err.code = match[1];
      }
      utils.callback_or_emit(this, command_obj.callback, err);
    };
    RedisClient.prototype.drain = function() {
      this.should_buffer = false;
    };
    function normal_reply(self, reply) {
      var command_obj = self.command_queue.shift();
      if (typeof command_obj.callback === "function") {
        if (command_obj.command !== "exec") {
          reply = self.handle_reply(reply, command_obj.command, command_obj.buffer_args);
        }
        command_obj.callback(null, reply);
      } else {
        debug("No callback for reply");
      }
    }
    function subscribe_unsubscribe(self, reply, type) {
      var command_obj = self.command_queue.get(0);
      var buffer = self.options.return_buffers || self.options.detect_buffers && command_obj.buffer_args;
      var channel = buffer || reply[1] === null ? reply[1] : reply[1].toString();
      var count = +reply[2];
      debug(type, channel);
      if (channel !== null) {
        self.emit(type, channel, count);
        if (type === "subscribe" || type === "psubscribe") {
          self.subscription_set[type + "_" + channel] = channel;
        } else {
          type = type === "unsubscribe" ? "subscribe" : "psubscribe";
          delete self.subscription_set[type + "_" + channel];
        }
      }
      if (command_obj.args.length === 1 || self.sub_commands_left === 1 || command_obj.args.length === 0 && (count === 0 || channel === null)) {
        if (count === 0) {
          var running_command;
          var i = 1;
          self.pub_sub_mode = 0;
          while (running_command = self.command_queue.get(i)) {
            if (SUBSCRIBE_COMMANDS[running_command.command]) {
              self.pub_sub_mode = i;
              break;
            }
            i++;
          }
        }
        self.command_queue.shift();
        if (typeof command_obj.callback === "function") {
          command_obj.callback(null, channel);
        }
        self.sub_commands_left = 0;
      } else {
        if (self.sub_commands_left !== 0) {
          self.sub_commands_left--;
        } else {
          self.sub_commands_left = command_obj.args.length ? command_obj.args.length - 1 : count;
        }
      }
    }
    function return_pub_sub(self, reply) {
      var type = reply[0].toString();
      if (type === "message") {
        if (!self.options.return_buffers || self.message_buffers) {
          self.emit("message", reply[1].toString(), reply[2].toString());
          self.emit("message_buffer", reply[1], reply[2]);
          self.emit("messageBuffer", reply[1], reply[2]);
        } else {
          self.emit("message", reply[1], reply[2]);
        }
      } else if (type === "pmessage") {
        if (!self.options.return_buffers || self.message_buffers) {
          self.emit("pmessage", reply[1].toString(), reply[2].toString(), reply[3].toString());
          self.emit("pmessage_buffer", reply[1], reply[2], reply[3]);
          self.emit("pmessageBuffer", reply[1], reply[2], reply[3]);
        } else {
          self.emit("pmessage", reply[1], reply[2], reply[3]);
        }
      } else {
        subscribe_unsubscribe(self, reply, type);
      }
    }
    RedisClient.prototype.return_reply = function(reply) {
      if (this.monitoring) {
        var replyStr;
        if (this.buffers && Buffer.isBuffer(reply)) {
          replyStr = reply.toString();
        } else {
          replyStr = reply;
        }
        if (typeof replyStr === "string" && utils.monitor_regex.test(replyStr)) {
          var timestamp = replyStr.slice(0, replyStr.indexOf(" "));
          var args = replyStr.slice(replyStr.indexOf('"') + 1, -1).split('" "').map(function(elem) {
            return elem.replace(/\\"/g, '"');
          });
          this.emit("monitor", timestamp, args, replyStr);
          return;
        }
      }
      if (this.pub_sub_mode === 0) {
        normal_reply(this, reply);
      } else if (this.pub_sub_mode !== 1) {
        this.pub_sub_mode--;
        normal_reply(this, reply);
      } else if (!(reply instanceof Array) || reply.length <= 2) {
        normal_reply(this, reply);
      } else {
        return_pub_sub(this, reply);
      }
    };
    function handle_offline_command(self, command_obj) {
      var command = command_obj.command;
      var err, msg;
      if (self.closing || !self.enable_offline_queue) {
        command = command.toUpperCase();
        if (!self.closing) {
          if (self.stream.writable) {
            msg = "The connection is not yet established and the offline queue is deactivated.";
          } else {
            msg = "Stream not writeable.";
          }
        } else {
          msg = "The connection is already closed.";
        }
        err = new errorClasses.AbortError({
          message: command + " can't be processed. " + msg,
          code: "NR_CLOSED",
          command
        });
        if (command_obj.args.length) {
          err.args = command_obj.args;
        }
        utils.reply_in_order(self, command_obj.callback, err);
      } else {
        debug("Queueing " + command + " for next server connection.");
        self.offline_queue.push(command_obj);
      }
      self.should_buffer = true;
    }
    RedisClient.prototype.internal_send_command = function(command_obj) {
      var arg, prefix_keys;
      var i = 0;
      var command_str = "";
      var args = command_obj.args;
      var command = command_obj.command;
      var len = args.length;
      var big_data = false;
      var args_copy = new Array(len);
      if (process.domain && command_obj.callback) {
        command_obj.callback = process.domain.bind(command_obj.callback);
      }
      if (this.ready === false || this.stream.writable === false) {
        handle_offline_command(this, command_obj);
        return false;
      }
      for (i = 0; i < len; i += 1) {
        if (typeof args[i] === "string") {
          if (args[i].length > 3e4) {
            big_data = true;
            args_copy[i] = Buffer.from(args[i], "utf8");
          } else {
            args_copy[i] = args[i];
          }
        } else if (typeof args[i] === "object") {
          if (args[i] instanceof Date) {
            args_copy[i] = args[i].toString();
          } else if (Buffer.isBuffer(args[i])) {
            args_copy[i] = args[i];
            command_obj.buffer_args = true;
            big_data = true;
          } else {
            var invalidArgError = new Error(
              "node_redis: The " + command.toUpperCase() + " command contains a invalid argument type.\nOnly strings, dates and buffers are accepted. Please update your code to use valid argument types."
            );
            invalidArgError.command = command_obj.command.toUpperCase();
            if (command_obj.args && command_obj.args.length) {
              invalidArgError.args = command_obj.args;
            }
            if (command_obj.callback) {
              command_obj.callback(invalidArgError);
              return false;
            }
            throw invalidArgError;
          }
        } else if (typeof args[i] === "undefined") {
          var undefinedArgError = new Error(
            "node_redis: The " + command.toUpperCase() + ' command contains a invalid argument type of "undefined".\nOnly strings, dates and buffers are accepted. Please update your code to use valid argument types.'
          );
          undefinedArgError.command = command_obj.command.toUpperCase();
          if (command_obj.args && command_obj.args.length) {
            undefinedArgError.args = command_obj.args;
          }
          command_obj.callback(undefinedArgError);
          return false;
        } else {
          args_copy[i] = "" + args[i];
        }
      }
      if (this.options.prefix) {
        prefix_keys = commands.getKeyIndexes(command, args_copy);
        for (i = prefix_keys.pop(); i !== void 0; i = prefix_keys.pop()) {
          args_copy[i] = this.options.prefix + args_copy[i];
        }
      }
      if (this.options.rename_commands && this.options.rename_commands[command]) {
        command = this.options.rename_commands[command];
      }
      command_str = "*" + (len + 1) + "\r\n$" + command.length + "\r\n" + command + "\r\n";
      if (big_data === false) {
        for (i = 0; i < len; i += 1) {
          arg = args_copy[i];
          command_str += "$" + Buffer.byteLength(arg) + "\r\n" + arg + "\r\n";
        }
        debug("Send " + this.address + " id " + this.connection_id + ": " + command_str);
        this.write(command_str);
      } else {
        debug("Send command (" + command_str + ") has Buffer arguments");
        this.fire_strings = false;
        this.write(command_str);
        for (i = 0; i < len; i += 1) {
          arg = args_copy[i];
          if (typeof arg === "string") {
            this.write("$" + Buffer.byteLength(arg) + "\r\n" + arg + "\r\n");
          } else {
            this.write("$" + arg.length + "\r\n");
            this.write(arg);
            this.write("\r\n");
          }
          debug("send_command: buffer send " + arg.length + " bytes");
        }
      }
      if (command_obj.call_on_write) {
        command_obj.call_on_write();
      }
      if (this.reply === "ON") {
        this.command_queue.push(command_obj);
      } else {
        if (command_obj.callback) {
          utils.reply_in_order(this, command_obj.callback, null, void 0, this.command_queue);
        }
        if (this.reply === "SKIP") {
          this.reply = "SKIP_ONE_MORE";
        } else if (this.reply === "SKIP_ONE_MORE") {
          this.reply = "ON";
        }
      }
      return !this.should_buffer;
    };
    RedisClient.prototype.write_strings = function() {
      var str = "";
      for (var command = this.pipeline_queue.shift(); command; command = this.pipeline_queue.shift()) {
        if (str.length + command.length > 4 * 1024 * 1024) {
          this.should_buffer = !this.stream.write(str);
          str = "";
        }
        str += command;
      }
      if (str !== "") {
        this.should_buffer = !this.stream.write(str);
      }
    };
    RedisClient.prototype.write_buffers = function() {
      for (var command = this.pipeline_queue.shift(); command; command = this.pipeline_queue.shift()) {
        this.should_buffer = !this.stream.write(command);
      }
    };
    RedisClient.prototype.write = function(data) {
      if (this.pipeline === false) {
        this.should_buffer = !this.stream.write(data);
        return;
      }
      this.pipeline_queue.push(data);
    };
    Object.defineProperty(exports, "debugMode", {
      get: function() {
        return this.debug_mode;
      },
      set: function(val) {
        this.debug_mode = val;
      }
    });
    Object.defineProperty(RedisClient.prototype, "command_queue_length", {
      get: function() {
        return this.command_queue.length;
      }
    });
    Object.defineProperty(RedisClient.prototype, "offline_queue_length", {
      get: function() {
        return this.offline_queue.length;
      }
    });
    Object.defineProperty(RedisClient.prototype, "retryDelay", {
      get: function() {
        return this.retry_delay;
      }
    });
    Object.defineProperty(RedisClient.prototype, "retryBackoff", {
      get: function() {
        return this.retry_backoff;
      }
    });
    Object.defineProperty(RedisClient.prototype, "commandQueueLength", {
      get: function() {
        return this.command_queue.length;
      }
    });
    Object.defineProperty(RedisClient.prototype, "offlineQueueLength", {
      get: function() {
        return this.offline_queue.length;
      }
    });
    Object.defineProperty(RedisClient.prototype, "shouldBuffer", {
      get: function() {
        return this.should_buffer;
      }
    });
    Object.defineProperty(RedisClient.prototype, "connectionId", {
      get: function() {
        return this.connection_id;
      }
    });
    Object.defineProperty(RedisClient.prototype, "serverInfo", {
      get: function() {
        return this.server_info;
      }
    });
    exports.createClient = function() {
      return new RedisClient(unifyOptions.apply(null, arguments));
    };
    exports.RedisClient = RedisClient;
    exports.print = utils.print;
    exports.Multi = require_multi();
    exports.AbortError = errorClasses.AbortError;
    exports.RedisError = RedisErrors.RedisError;
    exports.ParserError = RedisErrors.ParserError;
    exports.ReplyError = RedisErrors.ReplyError;
    exports.AggregateError = errorClasses.AggregateError;
    require_individualCommands();
    require_extendedApi();
    exports.addCommand = exports.add_command = require_commands2();
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof(o) {
      "@babel/helpers - typeof";
      return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
    }
    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS({
  "node_modules/@babel/runtime/helpers/toPrimitive.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS({
  "node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    var toPrimitive = require_toPrimitive();
    function _toPropertyKey(arg) {
      var key = toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module) {
    var toPropertyKey = require_toPropertyKey();
    function _defineProperty(obj, key, value) {
      key = toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/objectSpread2.js
var require_objectSpread2 = __commonJS({
  "node_modules/@babel/runtime/helpers/objectSpread2.js"(exports, module) {
    var defineProperty = require_defineProperty();
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread2(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    module.exports = _objectSpread2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/arrayWithHoles.js
var require_arrayWithHoles = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayWithHoles.js"(exports, module) {
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/iterableToArrayLimit.js
var require_iterableToArrayLimit = __commonJS({
  "node_modules/@babel/runtime/helpers/iterableToArrayLimit.js"(exports, module) {
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t)
              return;
            f = false;
          } else
            for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true)
              ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u))
              return;
          } finally {
            if (o)
              throw n;
          }
        }
        return a;
      }
    }
    module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/arrayLikeToArray.js
var require_arrayLikeToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayLikeToArray.js"(exports, module) {
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
var require_unsupportedIterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"(exports, module) {
    var arrayLikeToArray = require_arrayLikeToArray();
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return arrayLikeToArray(o, minLen);
    }
    module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/nonIterableRest.js
var require_nonIterableRest = __commonJS({
  "node_modules/@babel/runtime/helpers/nonIterableRest.js"(exports, module) {
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/slicedToArray.js
var require_slicedToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/slicedToArray.js"(exports, module) {
    var arrayWithHoles = require_arrayWithHoles();
    var iterableToArrayLimit = require_iterableToArrayLimit();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableRest = require_nonIterableRest();
    function _slicedToArray(arr, i) {
      return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
    }
    module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js
var require_createForOfIteratorHelper = __commonJS({
  "node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js"(exports, module) {
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return {
            s: F,
            n: function n() {
              if (i >= o.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o[i++]
              };
            },
            e: function e(_e) {
              throw _e;
            },
            f: F
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function s() {
          it = it.call(o);
        },
        n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function e(_e2) {
          didErr = true;
          err = _e2;
        },
        f: function f() {
          try {
            if (!normalCompletion && it["return"] != null)
              it["return"]();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    module.exports = _createForOfIteratorHelper, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "node_modules/object-keys/implementation.js"(exports, module) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports, module) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "node_modules/has-proto/index.js"(exports, module) {
    "use strict";
    var test = {
      foo: {}
    };
    var $Object = Object;
    module.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation2();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
      return x.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
          return true;
        } catch (e) {
          return false;
        }
      }
      return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!hasPropertyDescriptors()) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports, module) {
    "use strict";
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = hasPropertyDescriptors && GetIntrinsic("%Object.defineProperty%", true);
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var $TypeError = GetIntrinsic("%TypeError%");
    var gopd = require_gopd();
    module.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports, module) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var defineDataProperty = require_define_data_property();
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var supportsDescriptors = require_has_property_descriptors()();
    var defineProperty = function(object, name, value, predicate) {
      if (name in object) {
        if (predicate === true) {
          if (object[name] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        defineDataProperty(object, name, value, true);
      } else {
        defineDataProperty(object, name, value);
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// node_modules/es-abstract/2019/IsPropertyKey.js
var require_IsPropertyKey = __commonJS({
  "node_modules/es-abstract/2019/IsPropertyKey.js"(exports, module) {
    "use strict";
    module.exports = function IsPropertyKey(argument) {
      return typeof argument === "string" || typeof argument === "symbol";
    };
  }
});

// node_modules/es-abstract/helpers/isPropertyDescriptor.js
var require_isPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/helpers/isPropertyDescriptor.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var hasOwn = require_hasown();
    var $TypeError = GetIntrinsic("%TypeError%");
    module.exports = function IsPropertyDescriptor(ES, Desc) {
      if (ES.Type(Desc) !== "Object") {
        return false;
      }
      var allowed = {
        "[[Configurable]]": true,
        "[[Enumerable]]": true,
        "[[Get]]": true,
        "[[Set]]": true,
        "[[Value]]": true,
        "[[Writable]]": true
      };
      for (var key in Desc) {
        if (hasOwn(Desc, key) && !allowed[key]) {
          return false;
        }
      }
      if (ES.IsDataDescriptor(Desc) && ES.IsAccessorDescriptor(Desc)) {
        throw new $TypeError("Property Descriptors may not be both accessor and data descriptors");
      }
      return true;
    };
  }
});

// node_modules/es-abstract/5/Type.js
var require_Type = __commonJS({
  "node_modules/es-abstract/5/Type.js"(exports, module) {
    "use strict";
    module.exports = function Type(x) {
      if (x === null) {
        return "Null";
      }
      if (typeof x === "undefined") {
        return "Undefined";
      }
      if (typeof x === "function" || typeof x === "object") {
        return "Object";
      }
      if (typeof x === "number") {
        return "Number";
      }
      if (typeof x === "boolean") {
        return "Boolean";
      }
      if (typeof x === "string") {
        return "String";
      }
    };
  }
});

// node_modules/es-abstract/2019/Type.js
var require_Type2 = __commonJS({
  "node_modules/es-abstract/2019/Type.js"(exports, module) {
    "use strict";
    var ES5Type = require_Type();
    module.exports = function Type(x) {
      if (typeof x === "symbol") {
        return "Symbol";
      }
      return ES5Type(x);
    };
  }
});

// node_modules/es-abstract/helpers/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/es-abstract/helpers/isNaN.js"(exports, module) {
    "use strict";
    module.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// node_modules/es-abstract/helpers/isFinite.js
var require_isFinite = __commonJS({
  "node_modules/es-abstract/helpers/isFinite.js"(exports, module) {
    "use strict";
    var $isNaN = require_isNaN();
    module.exports = function(x) {
      return (typeof x === "number" || typeof x === "bigint") && !$isNaN(x) && x !== Infinity && x !== -Infinity;
    };
  }
});

// node_modules/es-abstract/helpers/isInteger.js
var require_isInteger = __commonJS({
  "node_modules/es-abstract/helpers/isInteger.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $abs = GetIntrinsic("%Math.abs%");
    var $floor = GetIntrinsic("%Math.floor%");
    var $isNaN = require_isNaN();
    var $isFinite = require_isFinite();
    module.exports = function isInteger(argument) {
      if (typeof argument !== "number" || $isNaN(argument) || !$isFinite(argument)) {
        return false;
      }
      var absValue = $abs(argument);
      return $floor(absValue) === absValue;
    };
  }
});

// node_modules/es-abstract/helpers/isMatchRecord.js
var require_isMatchRecord = __commonJS({
  "node_modules/es-abstract/helpers/isMatchRecord.js"(exports, module) {
    "use strict";
    var hasOwn = require_hasown();
    module.exports = function isMatchRecord(record) {
      return hasOwn(record, "[[StartIndex]]") && hasOwn(record, "[[EndIndex]]") && record["[[StartIndex]]"] >= 0 && record["[[EndIndex]]"] >= record["[[StartIndex]]"] && String(parseInt(record["[[StartIndex]]"], 10)) === String(record["[[StartIndex]]"]) && String(parseInt(record["[[EndIndex]]"], 10)) === String(record["[[EndIndex]]"]);
    };
  }
});

// node_modules/es-abstract/helpers/assertRecord.js
var require_assertRecord = __commonJS({
  "node_modules/es-abstract/helpers/assertRecord.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var hasOwn = require_hasown();
    var isInteger = require_isInteger();
    var isMatchRecord = require_isMatchRecord();
    var predicates = {
      // https://262.ecma-international.org/6.0/#sec-property-descriptor-specification-type
      "Property Descriptor": function isPropertyDescriptor(Desc) {
        var allowed = {
          "[[Configurable]]": true,
          "[[Enumerable]]": true,
          "[[Get]]": true,
          "[[Set]]": true,
          "[[Value]]": true,
          "[[Writable]]": true
        };
        if (!Desc) {
          return false;
        }
        for (var key in Desc) {
          if (hasOwn(Desc, key) && !allowed[key]) {
            return false;
          }
        }
        var isData = hasOwn(Desc, "[[Value]]");
        var IsAccessor = hasOwn(Desc, "[[Get]]") || hasOwn(Desc, "[[Set]]");
        if (isData && IsAccessor) {
          throw new $TypeError("Property Descriptors may not be both accessor and data descriptors");
        }
        return true;
      },
      // https://262.ecma-international.org/13.0/#sec-match-records
      "Match Record": isMatchRecord,
      "Iterator Record": function isIteratorRecord(value) {
        return hasOwn(value, "[[Iterator]]") && hasOwn(value, "[[NextMethod]]") && hasOwn(value, "[[Done]]");
      },
      "PromiseCapability Record": function isPromiseCapabilityRecord(value) {
        return !!value && hasOwn(value, "[[Resolve]]") && typeof value["[[Resolve]]"] === "function" && hasOwn(value, "[[Reject]]") && typeof value["[[Reject]]"] === "function" && hasOwn(value, "[[Promise]]") && value["[[Promise]]"] && typeof value["[[Promise]]"].then === "function";
      },
      "AsyncGeneratorRequest Record": function isAsyncGeneratorRequestRecord(value) {
        return !!value && hasOwn(value, "[[Completion]]") && hasOwn(value, "[[Capability]]") && predicates["PromiseCapability Record"](value["[[Capability]]"]);
      },
      "RegExp Record": function isRegExpRecord(value) {
        return value && hasOwn(value, "[[IgnoreCase]]") && typeof value["[[IgnoreCase]]"] === "boolean" && hasOwn(value, "[[Multiline]]") && typeof value["[[Multiline]]"] === "boolean" && hasOwn(value, "[[DotAll]]") && typeof value["[[DotAll]]"] === "boolean" && hasOwn(value, "[[Unicode]]") && typeof value["[[Unicode]]"] === "boolean" && hasOwn(value, "[[CapturingGroupsCount]]") && typeof value["[[CapturingGroupsCount]]"] === "number" && isInteger(value["[[CapturingGroupsCount]]"]) && value["[[CapturingGroupsCount]]"] >= 0;
      }
    };
    module.exports = function assertRecord(Type, recordType, argumentName, value) {
      var predicate = predicates[recordType];
      if (typeof predicate !== "function") {
        throw new $SyntaxError("unknown record type: " + recordType);
      }
      if (Type(value) !== "Object" || !predicate(value)) {
        throw new $TypeError(argumentName + " must be a " + recordType);
      }
    };
  }
});

// node_modules/es-abstract/2019/IsAccessorDescriptor.js
var require_IsAccessorDescriptor = __commonJS({
  "node_modules/es-abstract/2019/IsAccessorDescriptor.js"(exports, module) {
    "use strict";
    var hasOwn = require_hasown();
    var Type = require_Type2();
    var assertRecord = require_assertRecord();
    module.exports = function IsAccessorDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      assertRecord(Type, "Property Descriptor", "Desc", Desc);
      if (!hasOwn(Desc, "[[Get]]") && !hasOwn(Desc, "[[Set]]")) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/es-abstract/2019/IsDataDescriptor.js
var require_IsDataDescriptor = __commonJS({
  "node_modules/es-abstract/2019/IsDataDescriptor.js"(exports, module) {
    "use strict";
    var hasOwn = require_hasown();
    var Type = require_Type2();
    var assertRecord = require_assertRecord();
    module.exports = function IsDataDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      assertRecord(Type, "Property Descriptor", "Desc", Desc);
      if (!hasOwn(Desc, "[[Value]]") && !hasOwn(Desc, "[[Writable]]")) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/es-abstract/helpers/isPrimitive.js
var require_isPrimitive = __commonJS({
  "node_modules/es-abstract/helpers/isPrimitive.js"(exports, module) {
    "use strict";
    module.exports = function isPrimitive(value) {
      return value === null || typeof value !== "function" && typeof value !== "object";
    };
  }
});

// node_modules/es-abstract/2019/IsExtensible.js
var require_IsExtensible = __commonJS({
  "node_modules/es-abstract/2019/IsExtensible.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $preventExtensions = GetIntrinsic("%Object.preventExtensions%", true);
    var $isExtensible = GetIntrinsic("%Object.isExtensible%", true);
    var isPrimitive = require_isPrimitive();
    module.exports = $preventExtensions ? function IsExtensible(obj) {
      return !isPrimitive(obj) && $isExtensible(obj);
    } : function IsExtensible(obj) {
      return !isPrimitive(obj);
    };
  }
});

// node_modules/es-abstract/2019/ToBoolean.js
var require_ToBoolean = __commonJS({
  "node_modules/es-abstract/2019/ToBoolean.js"(exports, module) {
    "use strict";
    module.exports = function ToBoolean(value) {
      return !!value;
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports, module) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// node_modules/es-abstract/2019/IsCallable.js
var require_IsCallable = __commonJS({
  "node_modules/es-abstract/2019/IsCallable.js"(exports, module) {
    "use strict";
    module.exports = require_is_callable();
  }
});

// node_modules/es-abstract/2019/ToPropertyDescriptor.js
var require_ToPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/2019/ToPropertyDescriptor.js"(exports, module) {
    "use strict";
    var hasOwn = require_hasown();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Type = require_Type2();
    var ToBoolean = require_ToBoolean();
    var IsCallable = require_IsCallable();
    module.exports = function ToPropertyDescriptor(Obj) {
      if (Type(Obj) !== "Object") {
        throw new $TypeError("ToPropertyDescriptor requires an object");
      }
      var desc = {};
      if (hasOwn(Obj, "enumerable")) {
        desc["[[Enumerable]]"] = ToBoolean(Obj.enumerable);
      }
      if (hasOwn(Obj, "configurable")) {
        desc["[[Configurable]]"] = ToBoolean(Obj.configurable);
      }
      if (hasOwn(Obj, "value")) {
        desc["[[Value]]"] = Obj.value;
      }
      if (hasOwn(Obj, "writable")) {
        desc["[[Writable]]"] = ToBoolean(Obj.writable);
      }
      if (hasOwn(Obj, "get")) {
        var getter = Obj.get;
        if (typeof getter !== "undefined" && !IsCallable(getter)) {
          throw new $TypeError("getter must be a function");
        }
        desc["[[Get]]"] = getter;
      }
      if (hasOwn(Obj, "set")) {
        var setter = Obj.set;
        if (typeof setter !== "undefined" && !IsCallable(setter)) {
          throw new $TypeError("setter must be a function");
        }
        desc["[[Set]]"] = setter;
      }
      if ((hasOwn(desc, "[[Get]]") || hasOwn(desc, "[[Set]]")) && (hasOwn(desc, "[[Value]]") || hasOwn(desc, "[[Writable]]"))) {
        throw new $TypeError("Invalid property descriptor. Cannot both specify accessors and a value or writable attribute");
      }
      return desc;
    };
  }
});

// node_modules/es-abstract/2019/SameValue.js
var require_SameValue = __commonJS({
  "node_modules/es-abstract/2019/SameValue.js"(exports, module) {
    "use strict";
    var $isNaN = require_isNaN();
    module.exports = function SameValue(x, y) {
      if (x === y) {
        if (x === 0) {
          return 1 / x === 1 / y;
        }
        return true;
      }
      return $isNaN(x) && $isNaN(y);
    };
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $floor = GetIntrinsic("%Math.floor%");
    module.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define(fn, "length", length, true, true);
        } else {
          define(fn, "length", length);
        }
      }
      return fn;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var setFunctionLength = require_set_function_length();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/es-abstract/helpers/IsArray.js
var require_IsArray = __commonJS({
  "node_modules/es-abstract/helpers/IsArray.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $Array = GetIntrinsic("%Array%");
    var toStr = !$Array.isArray && require_callBound()("Object.prototype.toString");
    module.exports = $Array.isArray || function IsArray(argument) {
      return toStr(argument) === "[object Array]";
    };
  }
});

// node_modules/es-abstract/helpers/DefineOwnProperty.js
var require_DefineOwnProperty = __commonJS({
  "node_modules/es-abstract/helpers/DefineOwnProperty.js"(exports, module) {
    "use strict";
    var hasPropertyDescriptors = require_has_property_descriptors();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = hasPropertyDescriptors() && GetIntrinsic("%Object.defineProperty%", true);
    var hasArrayLengthDefineBug = hasPropertyDescriptors.hasArrayLengthDefineBug();
    var isArray = hasArrayLengthDefineBug && require_IsArray();
    var callBound = require_callBound();
    var $isEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    module.exports = function DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, desc) {
      if (!$defineProperty) {
        if (!IsDataDescriptor(desc)) {
          return false;
        }
        if (!desc["[[Configurable]]"] || !desc["[[Writable]]"]) {
          return false;
        }
        if (P in O && $isEnumerable(O, P) !== !!desc["[[Enumerable]]"]) {
          return false;
        }
        var V = desc["[[Value]]"];
        O[P] = V;
        return SameValue(O[P], V);
      }
      if (hasArrayLengthDefineBug && P === "length" && "[[Value]]" in desc && isArray(O) && O.length !== desc["[[Value]]"]) {
        O.length = desc["[[Value]]"];
        return O.length === desc["[[Value]]"];
      }
      $defineProperty(O, P, FromPropertyDescriptor(desc));
      return true;
    };
  }
});

// node_modules/es-abstract/helpers/every.js
var require_every = __commonJS({
  "node_modules/es-abstract/helpers/every.js"(exports, module) {
    "use strict";
    module.exports = function every(array, predicate) {
      for (var i = 0; i < array.length; i += 1) {
        if (!predicate(array[i], i, array)) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/es-abstract/helpers/isSamePropertyDescriptor.js
var require_isSamePropertyDescriptor = __commonJS({
  "node_modules/es-abstract/helpers/isSamePropertyDescriptor.js"(exports, module) {
    "use strict";
    var every = require_every();
    module.exports = function isSamePropertyDescriptor(ES, D1, D2) {
      var fields = [
        "[[Configurable]]",
        "[[Enumerable]]",
        "[[Get]]",
        "[[Set]]",
        "[[Value]]",
        "[[Writable]]"
      ];
      return every(fields, function(field) {
        if (field in D1 !== field in D2) {
          return false;
        }
        return ES.SameValue(D1[field], D2[field]);
      });
    };
  }
});

// node_modules/es-abstract/helpers/fromPropertyDescriptor.js
var require_fromPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/helpers/fromPropertyDescriptor.js"(exports, module) {
    "use strict";
    module.exports = function fromPropertyDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return Desc;
      }
      var obj = {};
      if ("[[Value]]" in Desc) {
        obj.value = Desc["[[Value]]"];
      }
      if ("[[Writable]]" in Desc) {
        obj.writable = !!Desc["[[Writable]]"];
      }
      if ("[[Get]]" in Desc) {
        obj.get = Desc["[[Get]]"];
      }
      if ("[[Set]]" in Desc) {
        obj.set = Desc["[[Set]]"];
      }
      if ("[[Enumerable]]" in Desc) {
        obj.enumerable = !!Desc["[[Enumerable]]"];
      }
      if ("[[Configurable]]" in Desc) {
        obj.configurable = !!Desc["[[Configurable]]"];
      }
      return obj;
    };
  }
});

// node_modules/es-abstract/2019/FromPropertyDescriptor.js
var require_FromPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/2019/FromPropertyDescriptor.js"(exports, module) {
    "use strict";
    var assertRecord = require_assertRecord();
    var fromPropertyDescriptor = require_fromPropertyDescriptor();
    var Type = require_Type2();
    module.exports = function FromPropertyDescriptor(Desc) {
      if (typeof Desc !== "undefined") {
        assertRecord(Type, "Property Descriptor", "Desc", Desc);
      }
      return fromPropertyDescriptor(Desc);
    };
  }
});

// node_modules/es-abstract/2019/IsGenericDescriptor.js
var require_IsGenericDescriptor = __commonJS({
  "node_modules/es-abstract/2019/IsGenericDescriptor.js"(exports, module) {
    "use strict";
    var assertRecord = require_assertRecord();
    var IsAccessorDescriptor = require_IsAccessorDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var Type = require_Type2();
    module.exports = function IsGenericDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      assertRecord(Type, "Property Descriptor", "Desc", Desc);
      if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
        return true;
      }
      return false;
    };
  }
});

// node_modules/es-abstract/2019/ValidateAndApplyPropertyDescriptor.js
var require_ValidateAndApplyPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/2019/ValidateAndApplyPropertyDescriptor.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var DefineOwnProperty = require_DefineOwnProperty();
    var isPropertyDescriptor = require_isPropertyDescriptor();
    var isSamePropertyDescriptor = require_isSamePropertyDescriptor();
    var FromPropertyDescriptor = require_FromPropertyDescriptor();
    var IsAccessorDescriptor = require_IsAccessorDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var IsGenericDescriptor = require_IsGenericDescriptor();
    var IsPropertyKey = require_IsPropertyKey();
    var SameValue = require_SameValue();
    var Type = require_Type2();
    module.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
      var oType = Type(O);
      if (oType !== "Undefined" && oType !== "Object") {
        throw new $TypeError("Assertion failed: O must be undefined or an Object");
      }
      if (Type(extensible) !== "Boolean") {
        throw new $TypeError("Assertion failed: extensible must be a Boolean");
      }
      if (!isPropertyDescriptor({
        Type,
        IsDataDescriptor,
        IsAccessorDescriptor
      }, Desc)) {
        throw new $TypeError("Assertion failed: Desc must be a Property Descriptor");
      }
      if (Type(current) !== "Undefined" && !isPropertyDescriptor({
        Type,
        IsDataDescriptor,
        IsAccessorDescriptor
      }, current)) {
        throw new $TypeError("Assertion failed: current must be a Property Descriptor, or undefined");
      }
      if (oType !== "Undefined" && !IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: if O is not undefined, P must be a Property Key");
      }
      if (Type(current) === "Undefined") {
        if (!extensible) {
          return false;
        }
        if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
          if (oType !== "Undefined") {
            DefineOwnProperty(
              IsDataDescriptor,
              SameValue,
              FromPropertyDescriptor,
              O,
              P,
              {
                "[[Configurable]]": Desc["[[Configurable]]"],
                "[[Enumerable]]": Desc["[[Enumerable]]"],
                "[[Value]]": Desc["[[Value]]"],
                "[[Writable]]": Desc["[[Writable]]"]
              }
            );
          }
        } else {
          if (!IsAccessorDescriptor(Desc)) {
            throw new $TypeError("Assertion failed: Desc is not an accessor descriptor");
          }
          if (oType !== "Undefined") {
            return DefineOwnProperty(
              IsDataDescriptor,
              SameValue,
              FromPropertyDescriptor,
              O,
              P,
              Desc
            );
          }
        }
        return true;
      }
      if (IsGenericDescriptor(Desc) && !("[[Configurable]]" in Desc) && !("[[Enumerable]]" in Desc)) {
        return true;
      }
      if (isSamePropertyDescriptor({ SameValue }, Desc, current)) {
        return true;
      }
      if (!current["[[Configurable]]"]) {
        if (Desc["[[Configurable]]"]) {
          return false;
        }
        if ("[[Enumerable]]" in Desc && !Desc["[[Enumerable]]"] === !!current["[[Enumerable]]"]) {
          return false;
        }
      }
      if (IsGenericDescriptor(Desc)) {
      } else if (IsDataDescriptor(current) !== IsDataDescriptor(Desc)) {
        if (!current["[[Configurable]]"]) {
          return false;
        }
        if (IsDataDescriptor(current)) {
          if (oType !== "Undefined") {
            DefineOwnProperty(
              IsDataDescriptor,
              SameValue,
              FromPropertyDescriptor,
              O,
              P,
              {
                "[[Configurable]]": current["[[Configurable]]"],
                "[[Enumerable]]": current["[[Enumerable]]"],
                "[[Get]]": void 0
              }
            );
          }
        } else if (oType !== "Undefined") {
          DefineOwnProperty(
            IsDataDescriptor,
            SameValue,
            FromPropertyDescriptor,
            O,
            P,
            {
              "[[Configurable]]": current["[[Configurable]]"],
              "[[Enumerable]]": current["[[Enumerable]]"],
              "[[Value]]": void 0
            }
          );
        }
      } else if (IsDataDescriptor(current) && IsDataDescriptor(Desc)) {
        if (!current["[[Configurable]]"] && !current["[[Writable]]"]) {
          if ("[[Writable]]" in Desc && Desc["[[Writable]]"]) {
            return false;
          }
          if ("[[Value]]" in Desc && !SameValue(Desc["[[Value]]"], current["[[Value]]"])) {
            return false;
          }
          return true;
        }
      } else if (IsAccessorDescriptor(current) && IsAccessorDescriptor(Desc)) {
        if (!current["[[Configurable]]"]) {
          if ("[[Set]]" in Desc && !SameValue(Desc["[[Set]]"], current["[[Set]]"])) {
            return false;
          }
          if ("[[Get]]" in Desc && !SameValue(Desc["[[Get]]"], current["[[Get]]"])) {
            return false;
          }
          return true;
        }
      } else {
        throw new $TypeError("Assertion failed: current and Desc are not both data, both accessors, or one accessor and one data.");
      }
      if (oType !== "Undefined") {
        return DefineOwnProperty(
          IsDataDescriptor,
          SameValue,
          FromPropertyDescriptor,
          O,
          P,
          Desc
        );
      }
      return true;
    };
  }
});

// node_modules/es-abstract/2019/OrdinaryDefineOwnProperty.js
var require_OrdinaryDefineOwnProperty = __commonJS({
  "node_modules/es-abstract/2019/OrdinaryDefineOwnProperty.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = require_gopd();
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var $TypeError = GetIntrinsic("%TypeError%");
    var isPropertyDescriptor = require_isPropertyDescriptor();
    var IsAccessorDescriptor = require_IsAccessorDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var IsExtensible = require_IsExtensible();
    var IsPropertyKey = require_IsPropertyKey();
    var ToPropertyDescriptor = require_ToPropertyDescriptor();
    var SameValue = require_SameValue();
    var Type = require_Type2();
    var ValidateAndApplyPropertyDescriptor = require_ValidateAndApplyPropertyDescriptor();
    module.exports = function OrdinaryDefineOwnProperty(O, P, Desc) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: O must be an Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: P must be a Property Key");
      }
      if (!isPropertyDescriptor({
        Type,
        IsDataDescriptor,
        IsAccessorDescriptor
      }, Desc)) {
        throw new $TypeError("Assertion failed: Desc must be a Property Descriptor");
      }
      if (!$gOPD) {
        if (IsAccessorDescriptor(Desc)) {
          throw new $SyntaxError("This environment does not support accessor property descriptors.");
        }
        var creatingNormalDataProperty = !(P in O) && Desc["[[Writable]]"] && Desc["[[Enumerable]]"] && Desc["[[Configurable]]"] && "[[Value]]" in Desc;
        var settingExistingDataProperty = P in O && (!("[[Configurable]]" in Desc) || Desc["[[Configurable]]"]) && (!("[[Enumerable]]" in Desc) || Desc["[[Enumerable]]"]) && (!("[[Writable]]" in Desc) || Desc["[[Writable]]"]) && "[[Value]]" in Desc;
        if (creatingNormalDataProperty || settingExistingDataProperty) {
          O[P] = Desc["[[Value]]"];
          return SameValue(O[P], Desc["[[Value]]"]);
        }
        throw new $SyntaxError("This environment does not support defining non-writable, non-enumerable, or non-configurable properties");
      }
      var desc = $gOPD(O, P);
      var current = desc && ToPropertyDescriptor(desc);
      var extensible = IsExtensible(O);
      return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);
    };
  }
});

// node_modules/es-abstract/2019/CreateDataProperty.js
var require_CreateDataProperty = __commonJS({
  "node_modules/es-abstract/2019/CreateDataProperty.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var IsPropertyKey = require_IsPropertyKey();
    var OrdinaryDefineOwnProperty = require_OrdinaryDefineOwnProperty();
    var Type = require_Type2();
    module.exports = function CreateDataProperty(O, P, V) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var newDesc = {
        "[[Configurable]]": true,
        "[[Enumerable]]": true,
        "[[Value]]": V,
        "[[Writable]]": true
      };
      return OrdinaryDefineOwnProperty(O, P, newDesc);
    };
  }
});

// node_modules/es-abstract/5/CheckObjectCoercible.js
var require_CheckObjectCoercible = __commonJS({
  "node_modules/es-abstract/5/CheckObjectCoercible.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    module.exports = function CheckObjectCoercible(value, optMessage) {
      if (value == null) {
        throw new $TypeError(optMessage || "Cannot call method on " + value);
      }
      return value;
    };
  }
});

// node_modules/es-abstract/2019/RequireObjectCoercible.js
var require_RequireObjectCoercible = __commonJS({
  "node_modules/es-abstract/2019/RequireObjectCoercible.js"(exports, module) {
    "use strict";
    module.exports = require_CheckObjectCoercible();
  }
});

// node_modules/es-abstract/2019/ToObject.js
var require_ToObject = __commonJS({
  "node_modules/es-abstract/2019/ToObject.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $Object = GetIntrinsic("%Object%");
    var RequireObjectCoercible = require_RequireObjectCoercible();
    module.exports = function ToObject(value) {
      RequireObjectCoercible(value);
      return $Object(value);
    };
  }
});

// node_modules/es-abstract/helpers/callBound.js
var require_callBound2 = __commonJS({
  "node_modules/es-abstract/helpers/callBound.js"(exports, module) {
    "use strict";
    module.exports = require_callBound();
  }
});

// node_modules/object.getownpropertydescriptors/implementation.js
var require_implementation3 = __commonJS({
  "node_modules/object.getownpropertydescriptors/implementation.js"(exports, module) {
    "use strict";
    var CreateDataProperty = require_CreateDataProperty();
    var IsCallable = require_IsCallable();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var ToObject = require_ToObject();
    var callBound = require_callBound2();
    var $gOPD = Object.getOwnPropertyDescriptor;
    var $getOwnNames = Object.getOwnPropertyNames;
    var $getSymbols = Object.getOwnPropertySymbols;
    var $concat = callBound("Array.prototype.concat");
    var $reduce = callBound("Array.prototype.reduce");
    var getAll = $getSymbols ? function(obj) {
      return $concat($getOwnNames(obj), $getSymbols(obj));
    } : $getOwnNames;
    var isES5 = IsCallable($gOPD) && IsCallable($getOwnNames);
    module.exports = function getOwnPropertyDescriptors(value) {
      RequireObjectCoercible(value);
      if (!isES5) {
        throw new TypeError("getOwnPropertyDescriptors requires Object.getOwnPropertyDescriptor");
      }
      var O = ToObject(value);
      return $reduce(
        getAll(O),
        function(acc, key) {
          var descriptor = $gOPD(O, key);
          if (typeof descriptor !== "undefined") {
            CreateDataProperty(acc, key, descriptor);
          }
          return acc;
        },
        {}
      );
    };
  }
});

// node_modules/object.getownpropertydescriptors/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/object.getownpropertydescriptors/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation3();
    module.exports = function getPolyfill() {
      return typeof Object.getOwnPropertyDescriptors === "function" ? Object.getOwnPropertyDescriptors : implementation;
    };
  }
});

// node_modules/object.getownpropertydescriptors/shim.js
var require_shim = __commonJS({
  "node_modules/object.getownpropertydescriptors/shim.js"(exports, module) {
    "use strict";
    var getPolyfill = require_polyfill();
    var define = require_define_properties();
    module.exports = function shimGetOwnPropertyDescriptors() {
      var polyfill = getPolyfill();
      define(
        Object,
        { getOwnPropertyDescriptors: polyfill },
        { getOwnPropertyDescriptors: function() {
          return Object.getOwnPropertyDescriptors !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// node_modules/object.getownpropertydescriptors/index.js
var require_object = __commonJS({
  "node_modules/object.getownpropertydescriptors/index.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    define(implementation, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = implementation;
  }
});

// node_modules/promise-callbacks/dist/index.js
var require_dist = __commonJS({
  "node_modules/promise-callbacks/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var _objectSpread = _interopDefault(require_objectSpread2());
    var _slicedToArray = _interopDefault(require_slicedToArray());
    var _createForOfIteratorHelper = _interopDefault(require_createForOfIteratorHelper());
    var getOwnPropertyDescriptors = _interopDefault(require_object());
    var tick = typeof process === "object" ? process.nextTick : function(fn) {
      return setTimeout(function() {
        return fn();
      }, 0);
    };
    function asCallback(promise, cb) {
      if (typeof cb !== "function") {
        throw new TypeError("callback must be a function");
      }
      var callback = function callback2() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return tick(function() {
          return cb.apply(void 0, args);
        });
      };
      promise.then(function(res) {
        return callback(null, res);
      }, callback);
    }
    function delay(time, value) {
      return new Promise(function(resolve) {
        return setTimeout(resolve, time, value);
      });
    }
    function immediate(value) {
      return new Promise(function(resolve) {
        return setImmediate(resolve, value);
      });
    }
    var nextTick = typeof process === "object" ? function nextTick2(value) {
      return new Promise(function(resolve) {
        return process.nextTick(resolve, value);
      });
    } : function nextTick2(value) {
      return Promise.resolve(value).then(function(value2) {
        return value2;
      });
    };
    var fromEntries = Object.fromEntries || function fromEntries2(entries) {
      var obj = {};
      var _iterator = _createForOfIteratorHelper(entries), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], value = _step$value[1];
          obj[key] = value;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return obj;
    };
    function objectAll(object) {
      if (!object || typeof object !== "object") {
        return Promise.reject(new TypeError("objectAll requires an object"));
      }
      var entries = [];
      var _loop = function _loop2(key2) {
        if (hasOwnProperty.call(object, key2)) {
          entries.push(Promise.resolve(object[key2]).then(function(resolved) {
            return [key2, resolved];
          }));
        }
      };
      for (var key in object) {
        _loop(key);
      }
      return Promise.all(entries).then(fromEntries);
    }
    var TimeoutError = class extends Error {
    };
    function voidAll(iter) {
      return new Promise(function(resolve, reject) {
        var n = 0, total = 0, ready = false;
        try {
          var _iterator = _createForOfIteratorHelper(iter), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var value = _step.value;
              Promise.resolve(value).then(function() {
                ++n;
                if (ready && n === total)
                  resolve();
              }, reject);
              ++total;
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          ready = true;
          if (!total)
            resolve();
        } catch (err) {
          reject(err);
        }
      });
    }
    function waitOn(emitter, event, waitError) {
      if (waitError) {
        return new Promise(function(resolve, reject) {
          function unbind() {
            emitter.removeListener("error", onError);
            emitter.removeListener(event, onEvent);
          }
          function onEvent(value) {
            unbind();
            resolve(value);
          }
          function onError(err) {
            unbind();
            reject(err);
          }
          emitter.on("error", onError);
          emitter.on(event, onEvent);
        });
      }
      return new Promise(function(resolve) {
        return emitter.once(event, resolve);
      });
    }
    function withTimeout(promise, delay2, message) {
      var timeout2;
      var timeoutPromise = new Promise(function(resolve, reject) {
        var error = message instanceof Error ? message : new TimeoutError(message || "Operation timed out.");
        timeout2 = setTimeout(reject, delay2, error);
      });
      return Promise.race([promise, timeoutPromise]).then(function(value) {
        clearTimeout(timeout2);
        return value;
      }, function(err) {
        clearTimeout(timeout2);
        throw err;
      });
    }
    function callbackBuilder(resolve, reject, options) {
      var variadic;
      if (options) {
        variadic = options.variadic;
      }
      var called = false;
      return function callback(err, value) {
        if (called) {
          throw new Error("the deferred callback has already been called");
        }
        called = true;
        if (err) {
          reject(err);
        } else if (Array.isArray(variadic)) {
          var obj = {};
          for (var i = 0; i < variadic.length; i++) {
            obj[variadic[i]] = arguments[i + 1];
          }
          resolve(obj);
        } else if (variadic) {
          var args = new Array(arguments.length - 1);
          for (var _i = 0; _i < args.length; ++_i) {
            args[_i] = arguments[_i + 1];
          }
          resolve(args);
        } else {
          resolve(value);
        }
      };
    }
    var sentinel = /* @__PURE__ */ Object.create(null);
    function wrapAsync(fn, options) {
      var catchExceptions = options && options.catchExceptions;
      if (typeof catchExceptions !== "boolean") {
        catchExceptions = true;
      }
      return function asyncWrapper() {
        var _arguments = arguments, _this = this;
        var syncErr = sentinel;
        var promise = new Promise(function(resolve, reject) {
          var cb = callbackBuilder(resolve, reject, options), args = Array.from(_arguments);
          args.push(cb);
          var res;
          try {
            res = fn.apply(_this, args);
          } catch (e) {
            if (catchExceptions) {
              reject(e);
            } else {
              syncErr = e;
              resolve();
            }
            return;
          }
          if (res && typeof res.then === "function") {
            resolve(res);
          }
        });
        if (syncErr !== sentinel)
          throw syncErr;
        return promise;
      };
    }
    var staticProperties = Object.freeze({
      __proto__: null,
      asCallback,
      delay,
      immediate,
      nextTick,
      objectAll,
      TimeoutError,
      voidAll,
      waitOn,
      withTimeout,
      wrapAsync
    });
    function patchPromise() {
      var props = {};
      for (var _i = 0, _Object$entries = Object.entries(staticProperties); _i < _Object$entries.length; _i++) {
        var entry = _Object$entries[_i];
        var fnName = entry[0], fn = entry[1];
        if (Promise[fnName] && Promise[fnName] !== fn) {
          throw new Error(`Promise already defines ${fnName}.`);
        }
        props[fnName] = {
          configurable: true,
          enumerable: false,
          writable: true,
          value: fn
        };
      }
      Object.defineProperties(Promise, props);
    }
    function unpatchPromise() {
      for (var _i2 = 0, _Object$entries2 = Object.entries(staticProperties); _i2 < _Object$entries2.length; _i2++) {
        var entry = _Object$entries2[_i2];
        var fnName = entry[0], fn = entry[1];
        if (Promise[fnName] === fn) {
          delete Promise[fnName];
        }
      }
    }
    var statics = _objectSpread({}, staticProperties);
    function asCallback$1(cb) {
      asCallback(this, cb);
    }
    function timeout(delay2, message) {
      return withTimeout(this, delay2, message);
    }
    var methods = {
      asCallback: asCallback$1,
      timeout
    };
    function patchPromise$1() {
      var props = {};
      for (var _i = 0, _Object$entries = Object.entries(methods); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), name = _Object$entries$_i[0], method = _Object$entries$_i[1];
        if (Promise.prototype[name] && Promise.prototype[name] !== method) {
          throw new Error(`\`Promise\` already defines method \`${name}\``);
        }
        props[name] = {
          configurable: true,
          enumerable: false,
          writable: true,
          value: method
        };
      }
      Object.defineProperties(Promise.prototype, props);
    }
    function unpatchPromise$1() {
      for (var _i2 = 0, _Object$entries2 = Object.entries(methods); _i2 < _Object$entries2.length; _i2++) {
        var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2), name = _Object$entries2$_i[0], method = _Object$entries2$_i[1];
        if (Promise.prototype[name] === method) {
          delete Promise.prototype[name];
        }
      }
    }
    function callAsync(fn) {
      return new Promise(function(resolve, reject) {
        return fn(callbackBuilder(resolve, reject));
      });
    }
    var Defer = class {
      constructor() {
        var _this = this;
        this.promise = new Promise(function(resolve, reject) {
          _this.resolve = resolve;
          _this.reject = reject;
        });
      }
    };
    function defer() {
      return new Defer();
    }
    function deferred(options) {
      var args = null;
      var promise = new Promise(function(resolve, reject) {
        return args = [resolve, reject, options];
      });
      promise.defer = function defer2() {
        if (!args)
          throw new Error("defer has already been called");
        var callback = callbackBuilder.apply(void 0, args);
        args = null;
        return callback;
      };
      return promise;
    }
    var kCustomPromisifiedSymbol = Symbol.for("util.promisify.custom");
    function promisify(orig, options) {
      if (typeof orig !== "function") {
        throw new TypeError("promisify requires a function");
      }
      if (orig[kCustomPromisifiedSymbol]) {
        var _fn = orig[kCustomPromisifiedSymbol];
        if (typeof _fn !== "function") {
          throw new TypeError("The [util.promisify.custom] property must be a function");
        }
        Object.defineProperty(_fn, kCustomPromisifiedSymbol, {
          value: _fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return _fn;
      }
      function fn() {
        var _this = this;
        var args = Array.from(arguments);
        return new Promise(function(resolve, reject) {
          args.push(callbackBuilder(resolve, reject, options));
          try {
            orig.apply(_this, args);
          } catch (err) {
            reject(err);
          }
        });
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(orig));
      Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return Object.defineProperties(fn, getOwnPropertyDescriptors(orig));
    }
    function promisifyMethod(obj, methodName, options) {
      if (!obj) {
        throw new TypeError("promisify.method requires a truthy value");
      }
      return promisify(obj[methodName].bind(obj), options);
    }
    function promisifyMethods(obj, methodNames, options) {
      if (!obj) {
        throw new TypeError("promisify.methods requires a truthy value");
      }
      var out = {};
      var _iterator = _createForOfIteratorHelper(methodNames), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var methodName = _step.value;
          out[methodName] = promisify(obj[methodName].bind(obj), options);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return out;
    }
    function promisifyAll(obj, options) {
      if (!obj) {
        throw new TypeError("promisify.all requires a truthy value");
      }
      var out = {};
      for (var name in obj) {
        if (typeof obj[name] === "function") {
          out[name] = promisify(obj[name].bind(obj), options);
        }
      }
      return out;
    }
    promisify.custom = kCustomPromisifiedSymbol;
    promisify.all = promisifyAll;
    promisify.method = promisifyMethod;
    promisify.methods = promisifyMethods;
    promisify.promisifyAll = promisifyAll;
    promisify.promisifyMethods = promisifyMethods;
    function patchPromise$2() {
      patchPromise();
      patchPromise$1();
    }
    function unpatchPromise$2() {
      unpatchPromise();
      unpatchPromise$1();
    }
    exports.TimeoutError = TimeoutError;
    exports.asCallback = asCallback;
    exports.callAsync = callAsync;
    exports.defer = defer;
    exports.deferred = deferred;
    exports.delay = delay;
    exports.immediate = immediate;
    exports.nextTick = nextTick;
    exports.objectAll = objectAll;
    exports.patchPromise = patchPromise$2;
    exports.promisify = promisify;
    exports.promisifyAll = promisifyAll;
    exports.promisifyMethod = promisifyMethod;
    exports.promisifyMethods = promisifyMethods;
    exports.unpatchPromise = unpatchPromise$2;
    exports.voidAll = voidAll;
    exports.waitOn = waitOn;
    exports.withTimeout = withTimeout;
    exports.wrapAsync = wrapAsync;
  }
});

// node_modules/bee-queue/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/bee-queue/lib/helpers.js"(exports, module) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    function has(object, name) {
      return hasOwn.call(object, name);
    }
    function bool(input, defaultValue) {
      if (typeof input === "boolean") {
        return input;
      }
      return defaultValue;
    }
    function finallyRejectsWithInitial(promise, fn) {
      return promise.then(
        (value) => Promise.resolve(fn()).then(() => value),
        (err) => {
          const reject = () => Promise.reject(err);
          return new Promise((resolve) => resolve(fn())).then(reject, reject);
        }
      );
    }
    var promiseUtils = require_dist();
    module.exports = {
      asCallback: promiseUtils.asCallback,
      bool,
      callAsync: promiseUtils.callAsync,
      deferred: promiseUtils.deferred,
      delay: promiseUtils.delay,
      finallyRejectsWithInitial,
      has,
      waitOn: promiseUtils.waitOn,
      withTimeout: promiseUtils.withTimeout,
      wrapAsync: promiseUtils.wrapAsync
    };
  }
});

// node_modules/bee-queue/lib/redis.js
var require_redis2 = __commonJS({
  "node_modules/bee-queue/lib/redis.js"(exports) {
    "use strict";
    var redis = require_redis();
    var helpers = require_helpers();
    function createClient(settings, createNew) {
      let client;
      if (isClient(settings)) {
        client = settings;
        if (createNew) {
          client = client.duplicate();
        } else if (isReady(client)) {
          return Promise.resolve(client);
        }
      } else {
        if (typeof settings === "object") {
          settings = Object.assign({}, settings);
        }
        client = redis.createClient(settings);
      }
      return helpers.waitOn(client, "ready", true).then(
        () => client,
        // If we receive an error before the client becomes ready, we won't retain a
        // reference to it, so we should disconnect the client to prevent uncaught
        // exceptions.
        (err) => (disconnect(client), Promise.reject(err))
      );
    }
    function disconnect(client) {
      if (client.disconnect) {
        client.disconnect();
      } else {
        client.end(true);
      }
    }
    function isAbortError(err) {
      return err.name === "AbortError" || /* istanbul ignore next: this is only for ioredis */
      err.message === "Connection is closed.";
    }
    function isClient(object) {
      if (!object || typeof object !== "object")
        return false;
      const name = object.constructor.name;
      return name === "Redis" || name === "RedisClient";
    }
    function isReady(client) {
      return client.ready || client.status === "ready";
    }
    exports.createClient = createClient;
    exports.disconnect = disconnect;
    exports.isAbortError = isAbortError;
    exports.isClient = isClient;
    exports.isReady = isReady;
  }
});

// node_modules/bee-queue/lib/job.js
var require_job = __commonJS({
  "node_modules/bee-queue/lib/job.js"(exports, module) {
    "use strict";
    var Emitter = require_events().EventEmitter;
    var helpers = require_helpers();
    var Job = class _Job extends Emitter {
      constructor(queue, jobId, data, options) {
        super();
        this.queue = queue;
        this.id = jobId;
        this.progress = 0;
        this.data = data || {};
        this.options = options || {};
        this.options.timestamp = this.options.timestamp || Date.now();
        this.options.stacktraces = this.options.stacktraces || [];
        this.status = "created";
      }
      static fromId(queue, jobId, cb) {
        const promise = queue._commandable().then(
          (client) => helpers.callAsync(
            (done) => client.hget(queue.toKey("jobs"), jobId, done)
          )
        ).then((data) => data ? _Job.fromData(queue, jobId, data) : null);
        if (cb)
          helpers.asCallback(promise, cb);
        return promise;
      }
      static fromData(queue, jobId, data) {
        data = JSON.parse(data);
        const job = new _Job(queue, jobId, data.data, data.options);
        job.status = data.status;
        job.progress = data.progress;
        return job;
      }
      toData() {
        return JSON.stringify({
          data: this.data,
          options: this.options,
          status: this.status,
          progress: this.progress
        });
      }
      // For Queue#saveAll, this method is guaranteed to invoke evalScript
      // synchronously.
      _save(evalScript) {
        const toKey = this.queue.toKey.bind(this.queue);
        let promise;
        if (this.options.delay) {
          promise = evalScript([
            "addDelayedJob",
            4,
            toKey("id"),
            toKey("jobs"),
            toKey("delayed"),
            toKey("earlierDelayed"),
            this.id || "",
            this.toData(),
            this.options.delay
          ]);
          if (this.queue.settings.activateDelayedJobs) {
            promise = promise.then((jobId) => {
              if (jobId) {
                this.queue._delayedTimer.schedule(this.options.delay);
              }
              return jobId;
            });
          }
        } else {
          promise = evalScript([
            "addJob",
            3,
            toKey("id"),
            toKey("jobs"),
            toKey("waiting"),
            this.id || "",
            this.toData()
          ]);
        }
        return promise.then((jobId) => {
          this.id = jobId;
          if (jobId && this.queue.settings.storeJobs) {
            this.queue.jobs.set(jobId, this);
          }
          return this;
        });
      }
      save(cb) {
        const promise = this._save(
          (args) => this.queue._evalScript.apply(this.queue, args)
        );
        if (cb)
          helpers.asCallback(promise, cb);
        return promise;
      }
      setId(id) {
        this.id = id;
        return this;
      }
      retries(n) {
        if (n < 0) {
          throw new Error("Retries cannot be negative");
        }
        this.options.retries = n;
        return this;
      }
      delayUntil(timestamp) {
        if (timestamp && typeof timestamp.getTime === "function") {
          timestamp = timestamp.getTime();
        } else {
          timestamp = parseInt(timestamp, 10);
        }
        if (isNaN(timestamp) || timestamp < 0) {
          throw new Error("invalid delay timestamp");
        }
        if (timestamp > Date.now()) {
          this.options.delay = timestamp;
        }
        return this;
      }
      timeout(ms) {
        if (ms < 0) {
          throw new Error("Timeout cannot be negative");
        }
        this.options.timeout = ms;
        return this;
      }
      backoff(strategy, delay) {
        if (!this.queue.backoffStrategies.has(strategy)) {
          throw new Error("unknown strategy");
        }
        const isInvalidDelay = !Number.isSafeInteger(delay) || delay <= 0;
        if (strategy !== "immediate" && isInvalidDelay) {
          throw new Error("delay must be a positive integer");
        }
        this.options.backoff = {
          strategy,
          delay
        };
        return this;
      }
      reportProgress(progress, cb) {
        let promise;
        if (progress != null) {
          this.progress = progress;
          promise = this.queue._commandable().then(
            (client) => helpers.callAsync(
              (done) => client.publish(
                this.queue.toKey("events"),
                JSON.stringify({
                  id: this.id,
                  event: "progress",
                  data: progress
                }),
                done
              )
            )
          );
        } else {
          promise = Promise.reject(new Error("Progress cannot be empty"));
        }
        if (cb)
          helpers.asCallback(promise, cb);
        return promise;
      }
      remove(cb) {
        const promise = this.queue.removeJob(this.id).then(() => this);
        if (cb)
          helpers.asCallback(promise, cb);
        return promise;
      }
      retry(cb) {
        const promise = this.queue._commandable().then(
          (client) => helpers.callAsync(
            (done) => client.multi().srem(this.queue.toKey("failed"), this.id).lpush(this.queue.toKey("waiting"), this.id).exec(done)
          )
        );
        if (cb)
          helpers.asCallback(promise, cb);
        return promise;
      }
      isInSet(set, cb) {
        const promise = this.queue._commandable().then(
          (client) => helpers.callAsync(
            (done) => client.sismember(this.queue.toKey(set), this.id, done)
          )
        ).then((result) => result === 1);
        if (cb)
          helpers.asCallback(promise, cb);
        return promise;
      }
      /**
       * Compute the delay for rescheduling the job after it fails.
       *
       * @return {number} The number of milliseconds into the future to schedule it.
       *   Negative if no defined strategy or no remaining retries.
       */
      computeDelay() {
        const strategyName = this.options.backoff ? this.options.backoff.strategy : "immediate";
        const strategy = this.options.retries > 0 ? this.queue.backoffStrategies.get(strategyName) : null;
        return strategy ? strategy(this) : -1;
      }
    };
    module.exports = Job;
  }
});

// node_modules/bee-queue/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/bee-queue/lib/defaults.js"(exports, module) {
    "use strict";
    module.exports = {
      stallInterval: 5e3,
      // Avoid scheduling timers for further out than this period of time. The
      // workers will all poll on this interval, at minimum, to find new delayed
      // jobs.
      nearTermWindow: 20 * 60 * 1e3,
      // Avoids rapid churn during processing of nearly-concurrent events.
      delayedDebounce: 1e3,
      prefix: "bq",
      isWorker: true,
      getEvents: true,
      ensureScripts: true,
      activateDelayedJobs: false,
      sendEvents: true,
      storeJobs: true,
      removeOnSuccess: false,
      removeOnFailure: false,
      redisScanCount: 100,
      // first retry period after a brpoplpush failure, backoff is exponential
      initialRedisFailureRetryDelay: 1e3,
      // quitCommandClient is dependent on whether the redis setting was an actual
      // redis client, or just configuration options to create such a client.
      // Method-specific defaults.
      "#close": {
        timeout: 5e3
      },
      "#process": {
        concurrency: 1
      }
    };
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/bee-queue/lib/lua/index.js
var require_lua = __commonJS({
  "node_modules/bee-queue/lib/lua/index.js"(exports, module) {
    "use strict";
    var fs = require_fs();
    var crypto = require_crypto();
    var path = require_path();
    var helpers = require_helpers();
    var promisify = require_dist().promisify;
    var scripts = {};
    var shas = {};
    var scriptsRead = false;
    var scriptsPromise = null;
    var readFile = promisify.methods(fs, ["readFile"]).readFile;
    var readDir = promisify.methods(fs, ["readdir"]).readdir;
    function readScript(file) {
      return readFile(path.join(__dirname, file), "utf8").then((script) => {
        const name = file.slice(0, -4);
        scripts[name] = script;
        const hash = crypto.createHash("sha1");
        hash.update(script);
        shas[name] = hash.digest("hex");
      });
    }
    function readScripts() {
      if (scriptsRead)
        return scriptsPromise;
      scriptsRead = true;
      return scriptsPromise = readDir(__dirname).then(
        (files) => Promise.all(files.filter((file) => file.endsWith(".lua")).map(readScript))
      ).then(() => scripts);
    }
    function loadScriptIfMissing(client, scriptKey) {
      return helpers.callAsync((done) => client.script("exists", shas[scriptKey], done)).then(
        (exists) => exists[0] === 0 ? helpers.callAsync(
          (done) => client.script("load", scripts[scriptKey], done)
        ) : null
      );
    }
    function buildCache(client) {
      return readScripts().then(
        () => Promise.all(
          Object.keys(shas).map((key) => loadScriptIfMissing(client, key))
        )
      );
    }
    module.exports = {
      scripts,
      shas,
      buildCache
    };
  }
});

// node_modules/bee-queue/lib/backoff.js
var require_backoff = __commonJS({
  "node_modules/bee-queue/lib/backoff.js"(exports, module) {
    "use strict";
    var strategies = /* @__PURE__ */ new Map();
    strategies.set("immediate", () => 0);
    strategies.set("fixed", (job) => job.options.backoff.delay);
    strategies.set("exponential", (job) => {
      const backoff = job.options.backoff, delay = backoff.delay;
      backoff.delay *= 2;
      return delay;
    });
    module.exports = strategies;
  }
});

// node_modules/bee-queue/lib/eager-timer.js
var require_eager_timer = __commonJS({
  "node_modules/bee-queue/lib/eager-timer.js"(exports, module) {
    "use strict";
    var Emitter = require_events().EventEmitter;
    var EagerTimer = class extends Emitter {
      constructor(maxDelay) {
        super();
        if (!Number.isSafeInteger(maxDelay) || maxDelay <= 0) {
          throw new Error("maximum delay must be a positive integer");
        }
        this._maxDelay = maxDelay;
        this._nextTime = null;
        this._timer = null;
        this._stopped = false;
        this._boundTrigger = this._trigger.bind(this);
      }
      schedule(time) {
        if (this._stopped)
          return;
        const now = Date.now();
        if (time < 0 || time == null || isNaN(time)) {
          time = now + this._maxDelay;
        } else if (time <= now) {
          this._schedule(now + this._maxDelay);
          return this.emit("trigger");
        } else {
          time = Math.min(time, now + this._maxDelay);
        }
        if (!this._timer || time < this._nextTime) {
          this._schedule(time);
        }
      }
      stop() {
        this._stop();
        this._stopped = true;
      }
      // PRIVATE METHODS
      _stop() {
        if (this._timer) {
          clearTimeout(this._timer);
          this._nextTime = null;
          this._timer = null;
        }
      }
      _schedule(time) {
        const duration = time - Date.now();
        this._stop();
        this._nextTime = time;
        this._timer = setTimeout(this._boundTrigger, duration);
      }
      _trigger() {
        const now = Date.now(), remaining = this._nextTime - now;
        if (remaining > 0) {
          this._timer = setTimeout(this._boundTrigger, remaining);
          return;
        }
        this._schedule(now + this._maxDelay);
        this.emit("trigger");
      }
    };
    module.exports = EagerTimer;
  }
});

// node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "node_modules/p-finally/index.js"(exports, module) {
    "use strict";
    module.exports = async (promise, onFinally = () => {
    }) => {
      let value;
      try {
        value = await promise;
      } catch (error) {
        await onFinally();
        throw error;
      }
      await onFinally();
      return value;
    };
  }
});

// node_modules/bee-queue/lib/queue.js
var require_queue = __commonJS({
  "node_modules/bee-queue/lib/queue.js"(exports, module) {
    "use strict";
    var redis = require_redis2();
    var Emitter = require_events().EventEmitter;
    var Job = require_job();
    var defaults = require_defaults();
    var lua = require_lua();
    var helpers = require_helpers();
    var backoff = require_backoff();
    var EagerTimer = require_eager_timer();
    var finally_ = require_p_finally();
    var Queue = class extends Emitter {
      constructor(name, settings = {}) {
        super();
        this.name = name;
        this.paused = false;
        this.jobs = /* @__PURE__ */ new Map();
        this.activeJobs = /* @__PURE__ */ new Set();
        this.checkTimer = null;
        this.backoffStrategies = new Map(backoff);
        this._closed = null;
        this._isClosed = false;
        this._emitError = (err) => void this.emit("error", err);
        this._emitErrorAfterTick = (err) => void process.nextTick(() => this.emit("error", err));
        this.client = null;
        this.bclient = null;
        this.eclient = null;
        this.settings = {
          redis: settings.redis || {},
          quitCommandClient: settings.quitCommandClient,
          keyPrefix: (settings.prefix || defaults.prefix) + ":" + this.name + ":",
          autoConnect: helpers.bool(settings.autoConnect, true)
        };
        this._isReady = false;
        this._ready = false;
        for (const prop in defaults) {
          const def = defaults[prop], setting = settings[prop], type = typeof def;
          if (type === "boolean") {
            this.settings[prop] = typeof setting === "boolean" ? setting : def;
          } else if (type === "number") {
            this.settings[prop] = Number.isSafeInteger(setting) ? setting : def;
          }
        }
        if (this.settings.redis.socket) {
          this.settings.redis = Object.assign({}, this.settings.redis, {
            path: this.settings.redis.socket
          });
        }
        if (typeof this.settings.quitCommandClient !== "boolean") {
          this.settings.quitCommandClient = !redis.isClient(this.settings.redis);
        }
        this._delayedTimer = this.settings.activateDelayedJobs ? new EagerTimer(this.settings.nearTermWindow) : null;
        if (this._delayedTimer) {
          this._delayedTimer.on("trigger", this._activateDelayed.bind(this));
        }
        if (this.settings.autoConnect) {
          this.connect();
        }
      }
      makeClient(clientName, createNew) {
        return redis.createClient(this.settings.redis, createNew).then((client) => {
          client.on("error", this._emitError);
          return this[clientName] = client;
        });
      }
      connect() {
        return new Promise((resolve, reject) => {
          try {
            if (this._isReady)
              return resolve(this._isReady);
            const getEventPromise = () => {
              if (this.settings.getEvents || this.settings.activateDelayedJobs) {
                return this.makeClient("eclient", true).then(() => {
                  this.eclient.on("message", this._onMessage.bind(this));
                  const channels = [];
                  if (this.settings.getEvents) {
                    channels.push(this.toKey("events"));
                  }
                  if (this.settings.activateDelayedJobs) {
                    channels.push(this.toKey("earlierDelayed"));
                  }
                  return Promise.all(
                    channels.map(
                      (channel) => helpers.callAsync(
                        (done) => this.eclient.subscribe(channel, done)
                      )
                    )
                  );
                });
              }
              return null;
            };
            const eventsPromise = getEventPromise();
            this._ready = Promise.all([
              // Make the clients
              this.makeClient("client", false),
              this.settings.isWorker ? this.makeClient("bclient", true) : null,
              eventsPromise
            ]).then(() => {
              if (this.settings.ensureScripts) {
                return lua.buildCache(this.client);
              }
            }).then(() => {
              this._isReady = true;
              setImmediate(() => this.emit("ready"));
              resolve(this._isReady);
              return this;
            });
          } catch (err) {
            reject(err);
          }
        });
      }
      _onMessage(channel, message) {
        if (channel === this.toKey("earlierDelayed")) {
          this._delayedTimer.schedule(parseInt(message, 10));
          return;
        }
        message = JSON.parse(message);
        if (message.event === "failed" || message.event === "retrying") {
          message.data = new Error(message.data);
        }
        this.emit("job " + message.event, message.id, message.data);
        const job = this.jobs.get(message.id);
        if (job) {
          if (message.event === "progress") {
            job.progress = message.data;
          } else if (message.event === "retrying") {
            job.options.retries -= 1;
          }
          job.emit(message.event, message.data);
          if (message.event === "succeeded" || message.event === "failed") {
            this.jobs.delete(message.id);
          }
        }
      }
      isRunning() {
        return !this.paused;
      }
      ready(cb) {
        if (cb) {
          helpers.asCallback(
            this._ready.then(() => {
            }),
            cb
          );
        }
        return this._ready;
      }
      _commandable(requireBlocking) {
        if (requireBlocking ? this.paused : this._isClosed) {
          return Promise.reject(new Error("closed"));
        }
        if (this._isReady) {
          return Promise.resolve(requireBlocking ? this.bclient : this.client);
        }
        return this._ready.then(() => this._commandable(requireBlocking));
      }
      close(timeout, cb) {
        if (typeof timeout === "function") {
          cb = timeout;
          timeout = defaults["#close"].timeout;
        } else if (!Number.isSafeInteger(timeout) || timeout <= 0) {
          timeout = defaults["#close"].timeout;
        }
        if (this.paused) {
          if (cb)
            helpers.asCallback(this._closed, cb);
          return this._closed;
        }
        this.paused = true;
        if (this.checkTimer) {
          clearTimeout(this.checkTimer);
          this.checkTimer = null;
        }
        if (this._delayedTimer) {
          this._delayedTimer.stop();
        }
        const drain = () => helpers.finallyRejectsWithInitial(this._ready, () => {
          if (this.settings.isWorker) {
            redis.disconnect(this.bclient);
          }
          return Promise.all(
            Array.from(this.activeJobs, (promise) => promise.catch(() => {
            }))
          ).then(() => {
          });
        });
        const cleanup = () => {
          this._isClosed = true;
          const clients = [];
          if (this.client) {
            if (this.settings.quitCommandClient) {
              clients.push(this.client);
            } else {
              this.client.removeListener("error", this._emitError);
            }
          }
          if (this.eclient) {
            clients.push(this.eclient);
          }
          return Promise.all(
            clients.map((client) => helpers.callAsync((done) => client.quit(done)))
          );
        };
        const closed = helpers.finallyRejectsWithInitial(
          helpers.withTimeout(drain(), timeout),
          () => cleanup()
        );
        this._closed = closed;
        if (cb)
          helpers.asCallback(closed, cb);
        return closed;
      }
      destroy(cb) {
        const promise = this._commandable().then((client) => {
          const deleted = helpers.deferred();
          const args = [
            "id",
            "jobs",
            "stallBlock",
            "stalling",
            "waiting",
            "active",
            "succeeded",
            "failed",
            "delayed"
          ].map((key) => this.toKey(key));
          args.push(deleted.defer());
          client.del.apply(client, args);
          return deleted;
        });
        if (cb)
          helpers.asCallback(promise, cb);
        return promise;
      }
      checkHealth(cb) {
        const promise = this._commandable().then(
          (client) => helpers.callAsync(
            (done) => client.multi().llen(this.toKey("waiting")).llen(this.toKey("active")).scard(this.toKey("succeeded")).scard(this.toKey("failed")).zcard(this.toKey("delayed")).get(this.toKey("id")).exec(done)
          )
        ).then((results) => ({
          waiting: results[0],
          active: results[1],
          succeeded: results[2],
          failed: results[3],
          delayed: results[4],
          newestJob: results[5] ? parseInt(results[5], 10) : 0
        }));
        if (cb)
          helpers.asCallback(promise, cb);
        return promise;
      }
      _scanForJobs(key, cursor, size, set, cb) {
        const batchCount = Math.min(size, this.settings.redisScanCount);
        this.client.sscan(key, cursor, "COUNT", batchCount, (err, results) => {
          if (err) {
            return cb(err);
          }
          const nextCursor = results[0];
          const ids = results[1];
          for (const id of ids) {
            if (set.size === size)
              break;
            set.add(id);
          }
          if (nextCursor === "0" || set.size >= size) {
            return cb(null, set);
          }
          this._scanForJobs(key, nextCursor, size, set, cb);
        });
      }
      _addJobsByIds(jobs, ids) {
        return this._commandable().then((client) => {
          const got = helpers.deferred();
          const commandArgs = [this.toKey("jobs")].concat(ids, got.defer());
          client.hmget.apply(client, commandArgs);
          return got;
        }).then((dataArray) => {
          const count = ids.length;
          for (let i = 0; i < count; ++i) {
            const jobData = dataArray[i];
            if (jobData) {
              jobs.push(Job.fromData(this, ids[i], jobData));
            }
          }
          return jobs;
        });
      }
      /**
       * Get jobs from queue type.
       *
       * @param {String} type The queue type (failed, succeeded, waiting, etc.)
       * @param {?Object=} page An object containing some of the following fields.
       * @param {Number=} page.start Start of query range for waiting/active/delayed
       *   queue types. Defaults to 0.
       * @param {Number=} page.end End of query range for waiting/active/delayed
       *   queue types. Defaults to 100.
       * @param {Number=} page.size Number jobs to return for failed/succeeded (SET)
       *   types. Defaults to 100.
       * @param {Function=} callback Called with the equivalent of the returned
       *   promise.
       * @return {Promise<Job[]>} Resolves to the jobs the function found.
       */
      getJobs(type, page, cb) {
        if (typeof page === "function") {
          cb = page;
          page = null;
        }
        page = Object.assign(
          {
            size: 100,
            start: 0,
            end: 100
          },
          page
        );
        const promise = this._commandable().then((client) => {
          const idsPromise = helpers.deferred(), next = idsPromise.defer();
          const key = this.toKey(type);
          switch (type) {
            case "failed":
            case "succeeded":
              this._scanForJobs(key, "0", page.size, /* @__PURE__ */ new Set(), next);
              break;
            case "waiting":
            case "active":
              client.lrange(key, page.start, page.end, next);
              break;
            case "delayed":
              client.zrange(key, page.start, page.end, next);
              break;
            default:
              throw new Error("Improper queue type");
          }
          return idsPromise;
        }).then((ids) => {
          const jobs = [], idsToFetch = [];
          for (const jobId of ids) {
            const job = this.jobs.get(jobId);
            if (job) {
              jobs.push(job);
            } else {
              idsToFetch.push(jobId);
            }
          }
          if (!idsToFetch.length) {
            return jobs;
          }
          return this._addJobsByIds(jobs, idsToFetch);
        });
        if (cb)
          helpers.asCallback(promise, cb);
        return promise;
      }
      createJob(data) {
        return new Job(this, null, data);
      }
      getJob(jobId, cb) {
        const promise = this._commandable().then(
          () => this.jobs.has(jobId) ? this.jobs.get(jobId) : Job.fromId(this, jobId)
        ).then((job) => {
          if (job && this.settings.storeJobs) {
            this.jobs.set(jobId, job);
          }
          return job;
        });
        if (cb)
          helpers.asCallback(promise, cb);
        return promise;
      }
      removeJob(jobId, cb) {
        const promise = this._evalScript(
          "removeJob",
          7,
          this.toKey("succeeded"),
          this.toKey("failed"),
          this.toKey("waiting"),
          this.toKey("active"),
          this.toKey("stalling"),
          this.toKey("jobs"),
          this.toKey("delayed"),
          jobId
        ).then(() => {
          if (this.settings.storeJobs) {
            this.jobs.delete(jobId);
          }
          return this;
        });
        if (cb)
          helpers.asCallback(promise, cb);
        return promise;
      }
      _waitForJob() {
        return helpers.callAsync(
          (done) => this.bclient.brpoplpush(
            this.toKey("waiting"),
            this.toKey("active"),
            0,
            done
          )
        ).then(
          (jobId) => (
            // Note that the job may be null in the case that the client has
            // removed the job before processing can take place, but after the
            // brpoplpush has returned the job id.
            Job.fromId(this, jobId)
          ),
          (err) => {
            if (redis.isAbortError(err) && this.paused) {
              return null;
            }
            this.emit("error", err);
            this._redisFailureRetryDelay = this._redisFailureRetryDelay ? this._redisFailureRetryDelay * 2 : this.settings.initialRedisFailureRetryDelay;
            return helpers.delay(this._redisFailureRetryDelay).then(() => this._waitForJob());
          }
        );
      }
      _getNextJob() {
        this._redisFailureRetryDelay = 0;
        return this._commandable(true).then(() => this._waitForJob());
      }
      _runJob(job) {
        let psTimeout = null, completed = false;
        const preventStalling = () => {
          psTimeout = null;
          if (this._isClosed)
            return;
          finally_(this._preventStall(job.id), () => {
            if (completed || this._isClosed)
              return;
            const interval = this.settings.stallInterval / 2;
            psTimeout = setTimeout(preventStalling, interval);
          }).catch(this._emitErrorAfterTick);
        };
        preventStalling();
        const handleOutcome = (err, data) => {
          completed = true;
          if (psTimeout) {
            clearTimeout(psTimeout);
            psTimeout = null;
          }
          return this._finishJob(err, data, job);
        };
        let promise = this.handler(job);
        if (job.options.timeout) {
          const message = `Job ${job.id} timed out (${job.options.timeout} ms)`;
          promise = helpers.withTimeout(promise, job.options.timeout, message);
        }
        const jobPromise = finally_(
          promise.then((data) => handleOutcome(null, data), handleOutcome),
          // The only error that can happen here is either network- or
          // Redis-related, or if Queue#close times out while a job is processing,
          // and the job later finishes.
          () => this.activeJobs.delete(jobPromise)
        );
        this.activeJobs.add(jobPromise);
        return jobPromise;
      }
      _preventStall(jobId) {
        return helpers.callAsync(
          (done) => this.client.srem(this.toKey("stalling"), jobId, done)
        );
      }
      _finishJob(err, data, job) {
        if (this._isClosed) {
          const status2 = err ? "failed" : "succeeded";
          throw new Error(`unable to update the status of ${status2} job ${job.id}`);
        }
        const multi = this.client.multi().lrem(this.toKey("active"), 0, job.id).srem(this.toKey("stalling"), job.id);
        const delay = err ? job.computeDelay() : -1;
        const status = err ? delay >= 0 ? "retrying" : "failed" : "succeeded";
        job.status = status;
        if (err) {
          const errInfo = err.stack || err.message || err;
          job.options.stacktraces.unshift(errInfo);
        }
        switch (status) {
          case "failed":
            if (this.settings.removeOnFailure) {
              multi.hdel(this.toKey("jobs"), job.id);
            } else {
              multi.hset(this.toKey("jobs"), job.id, job.toData());
              multi.sadd(this.toKey("failed"), job.id);
            }
            break;
          case "retrying":
            --job.options.retries;
            multi.hset(this.toKey("jobs"), job.id, job.toData());
            if (delay === 0) {
              multi.lpush(this.toKey("waiting"), job.id);
            } else {
              const time = Date.now() + delay;
              multi.zadd(this.toKey("delayed"), time, job.id).publish(this.toKey("earlierDelayed"), time);
            }
            break;
          case "succeeded":
            if (this.settings.removeOnSuccess) {
              multi.hdel(this.toKey("jobs"), job.id);
            } else {
              multi.hset(this.toKey("jobs"), job.id, job.toData());
              multi.sadd(this.toKey("succeeded"), job.id);
            }
            break;
        }
        if (this.settings.sendEvents) {
          multi.publish(
            this.toKey("events"),
            JSON.stringify({
              id: job.id,
              event: status,
              data: err ? err.message : data
            })
          );
        }
        const result = err || data;
        return helpers.callAsync((done) => multi.exec(done)).then(() => [status, result]);
      }
      process(concurrency, handler) {
        if (!this.settings.isWorker) {
          throw new Error("Cannot call Queue#process on a non-worker");
        }
        if (this.handler) {
          throw new Error("Cannot call Queue#process twice");
        }
        if (this.paused) {
          throw new Error("closed");
        }
        if (typeof concurrency === "function") {
          handler = concurrency;
          concurrency = defaults["#process"].concurrency;
        }
        const catchExceptions = true;
        this.handler = helpers.wrapAsync(handler, catchExceptions);
        this.running = 0;
        this.queued = 1;
        this.concurrency = concurrency;
        const jobTick = () => {
          if (this.paused) {
            this.queued -= 1;
            return;
          }
          finally_(
            this._getNextJob().then((job) => {
              if (this.paused) {
                this.queued -= 1;
                return;
              }
              this.running += 1;
              this.queued -= 1;
              if (this.running + this.queued < this.concurrency) {
                this.queued += 1;
                setImmediate(jobTick);
              }
              if (!job) {
                return;
              }
              return this._runJob(job).then((results) => {
                this.running -= 1;
                this.queued += 1;
                if (results) {
                  const status = results[0], result = results[1];
                  this.emit(status, job, result);
                  const emitExtra = status === "retrying" ? "failed" : status === "failed" ? "failed:fatal" : null;
                  if (emitExtra)
                    this.emit(emitExtra, job, result);
                }
              }, this._emitErrorAfterTick);
            }),
            () => setImmediate(jobTick)
          ).catch(this._emitErrorAfterTick);
        };
        this._doStalledJobCheck().then(jobTick).catch(this._emitErrorAfterTick);
        this._activateDelayed();
        return this;
      }
      _doStalledJobCheck() {
        return this._evalScript(
          "checkStalledJobs",
          4,
          this.toKey("stallBlock"),
          this.toKey("stalling"),
          this.toKey("waiting"),
          this.toKey("active"),
          this.settings.stallInterval
        ).then((stalled) => {
          for (const jobId of stalled) {
            this.emit("stalled", jobId);
          }
          return stalled.length;
        });
      }
      _safeCheckStalledJobs(interval, cb) {
        const promise = this._checkStalledJobs(interval, cb);
        if (!cb)
          promise.catch(this._emitErrorAfterTick);
      }
      _scheduleStalledCheck(interval, cb) {
        if (this.checkTimer || this.paused)
          return;
        this.checkTimer = setTimeout(() => {
          this.checkTimer = null;
          this._safeCheckStalledJobs(interval, cb);
        }, interval);
      }
      _checkStalledJobs(interval, cb) {
        const promise = this._doStalledJobCheck();
        if (cb)
          helpers.asCallback(promise, cb);
        return interval && !this.checkTimer ? finally_(promise, () => {
          try {
            this._scheduleStalledCheck(interval, cb);
          } catch (err) {
            this._emitErrorAfterTick(err);
          }
        }) : promise;
      }
      /**
       * Check for stalled jobs.
       *
       * @param {Number=} interval The interval on which to check for stalled jobs.
       *   This should be set to half the stallInterval setting, to avoid
       *   unnecessary work.
       * @param {Function=} callback Called with the equivalent of the returned
       *   promise. If interval is provided, the callback will be invoked after each
       *   invocation of checkStalledJobs.
       * @return {Promise<Number>} Resolves to the number of stalled jobs the
       *   function found.
       */
      checkStalledJobs(interval, cb) {
        if (typeof interval === "function") {
          cb = interval;
          interval = null;
        } else if (!Number.isSafeInteger(interval)) {
          interval = null;
        }
        return this._checkStalledJobs(interval, cb);
      }
      /**
       * Save all the provided jobs, without waiting for each job to be created.
       * This pipelines the requests which avoids the waiting 2N*RTT for N jobs -
       * the client waits to receive each command result before sending the next
       * command. Note that this method does not support a callback parameter - you
       * must use the returned Promise.
       *
       * @param {Iterable<Job>} jobs The jobs to save. Jobs that have no ID will be
       *   assigned one by mutation.
       * @return {Promise<Map<Job, Error>>} The errors that occurred when saving
       *   jobs. Will be empty if no errors occurred. Will reject if there was an
       *   exception executing the batch or readying the connection.
       * @modifies {arguments}
       */
      saveAll(jobs) {
        return this._commandable().then((client) => {
          const batch = client.batch(), errors = /* @__PURE__ */ new Map();
          for (const job of jobs) {
            try {
              job._save((evalArgs) => this._evalScriptOn(batch, evalArgs)).catch((err) => void errors.set(job, err));
            } catch (err) {
              errors.set(job, err);
            }
          }
          return helpers.callAsync((done) => batch.exec(done)).then(() => errors);
        });
      }
      _activateDelayed() {
        if (!this.settings.activateDelayedJobs)
          return;
        this._evalScript(
          "raiseDelayedJobs",
          2,
          this.toKey("delayed"),
          this.toKey("waiting"),
          Date.now(),
          this.settings.delayedDebounce
        ).then(
          (results) => {
            const numRaised = results[0], nextOpportunity = results[1];
            if (numRaised) {
              this.emit("raised jobs", numRaised);
            }
            this._delayedTimer.schedule(parseInt(nextOpportunity, 10));
          },
          /* istanbul ignore next */
          (err) => {
            if (redis.isAbortError(err)) {
              if (this.paused)
                return;
              return this._activateDelayed();
            }
            this._emitErrorAfterTick(err);
          }
        );
      }
      toKey(str) {
        return this.settings.keyPrefix + str;
      }
      /**
       * Evaluate the named script on the given commandable object, which might be a
       * RedisClient or a Batch or Multi object. This exists to facilitate
       * command pipelining.
       *
       * @modifies {arguments}
       */
      _evalScriptOn(commandable, args) {
        args[0] = lua.shas[args[0]];
        return helpers.callAsync((done) => {
          args.push(done);
          commandable.evalsha.apply(commandable, args);
        });
      }
      /**
       * Evaluate the named script, return a promise with its results.
       *
       * Same parameter list/syntax as evalsha, except for the name.
       *
       * @param {string} name
       */
      _evalScript() {
        const args = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
          args[i] = arguments[i];
        }
        return this._commandable().then(
          (client) => this._evalScriptOn(client, args)
        );
      }
    };
    module.exports = Queue;
  }
});

// node_modules/bee-queue/index.js
var require_bee_queue = __commonJS({
  "node_modules/bee-queue/index.js"(exports, module) {
    module.exports = require_queue();
  }
});
export default require_bee_queue();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=bee-queue.js.map
